import { Callout } from "nextra/components";

<img
  src="https://upload.wikimedia.org/wikipedia/commons/a/a7/React-icon.svg"
  alt="React Logo"
  width="70"
  style={{ marginBottom: "1rem" }}
/>

# Flushing State Updates Synchronously ‚Äì Interview Questions & Answers

Use these questions to prepare for interviews or test your understanding of flushing state updates synchronously in React with `flushSync`.

> **üí° Pro Tip:** Try answering each question yourself before checking the answer. This will help you remember the concepts better!

---

## 4.1 ‚Äì Fundamentals ‚ö°

<div style={{ background: 'rgba(0, 100, 200, 0.10)', padding: '15px', borderRadius: '5px', marginBottom: '20px', border: '1px solid rgba(0, 100, 200, 0.15)', color: 'inherit' }}>

**Q1: What does `flushSync` do in React?**  
A: It forces React to flush any pending state updates and update the DOM synchronously, instead of batching updates asynchronously.

**Q2: When might you need to use `flushSync`?**  
A: When you need the DOM to reflect state changes immediately, such as for scrolling to a new item, measuring layout, or coordinating animations right after a state update.

**Q3: How do you use `flushSync` in a React component?**  
A: Import it from `react-dom` and wrap your state update(s) in a `flushSync(() => { ... })` call.

**Q4: What is the risk of overusing `flushSync`?**  
A: Overusing it can hurt performance by breaking React's batching optimizations, leading to more frequent and expensive DOM updates.

</div>

---

## 4.2 ‚Äì Scenarios & Practical Examples üõ†Ô∏è

<div style={{ background: 'rgba(200, 200, 100, 0.10)', padding: '15px', borderRadius: '5px', marginBottom: '20px', border: '1px solid rgba(200, 200, 100, 0.15)', color: 'inherit' }}>

### Scenario-Based Question:

**You have a todo list and want to scroll to the newest item immediately after adding it. How do you ensure the scroll happens after the DOM is updated?**

<details>
<summary>**Click to see a sample answer**</summary>

**Sample Answer:**  
Wrap the state update in `flushSync` so the DOM is updated before calling `scrollIntoView()`:

```jsx
import { flushSync } from "react-dom";

function handleAdd() {
  flushSync(() => {
    setTodos([...todos, newTodo]);
  });
  listRef.current.lastChild.scrollIntoView({ behavior: "smooth" });
}
```

</details>

**Q5: Can you use `flushSync` with multiple state updates?**  
A: Yes! You can batch several updates inside a single `flushSync` call to ensure all are applied before the DOM is read or manipulated.

**Q6: What is a common mistake when using `flushSync`?**  
A: Calling DOM methods (like `scrollIntoView`) before the state update is flushed, or using `flushSync` unnecessarily when normal batching would suffice.

</div>

---

## 4.3 ‚Äì Best Practices & Pitfalls üö©

<div style={{ background: 'rgba(230, 150, 70, 0.10)', padding: '15px', borderRadius: '5px', marginBottom: '20px', border: '1px solid rgba(230, 150, 70, 0.15)', color: 'inherit' }}>

**Q7: When should you avoid using `flushSync`?**  
A: Avoid it for routine state updates or in every event handler‚Äîprefer React's default batching for performance unless you have a specific need for synchronous DOM updates.

**Q8: What can happen if you manipulate the DOM directly after a state update without `flushSync`?**  
A: The DOM may not reflect the latest state, leading to bugs like scrolling to the wrong element or measuring outdated layout.

**Q9: How does `flushSync` compare to `useLayoutEffect` for synchronizing with the DOM?**  
A: `flushSync` updates the DOM immediately after the state change, while `useLayoutEffect` runs after the DOM is updated but is still asynchronous with respect to the event.

</div>

---

> **üöÄ Final Advice:** Use `flushSync` only when you need immediate DOM updates. For most cases, React's batching is more efficient and less error-prone!

<img
  src="https://upload.wikimedia.org/wikipedia/commons/a/a7/React-icon.svg"
  alt="React Interview Success"
  width="100"
  style={{ borderRadius: "8px", marginTop: "2rem" }}
/>
