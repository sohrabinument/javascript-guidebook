# Referencing Values with Refs

import { Callout } from "nextra/components";
import { Tabs } from "nextra/components";

<div className="flex items-center gap-3 mb-6">
  <span className="text-4xl">🎯</span>
  <div>
    <div className="text-gray-600 text-lg">
      Learn how to remember values without triggering re-renders
    </div>
  </div>
</div>

Imagine you need your React component to remember something, but you don't want it to re-render every time that "something" changes. That's exactly what **refs** are for!

<Callout type="info" emoji="💡">
  **Think of refs like a notebook**: You can write notes in it, read them later,
  and update them anytime - but React won't bother re-rendering your component
  when you do.
</Callout>

---

## 🏗️ Adding a Ref to Your Component

Getting started with refs is super simple. First, import the `useRef` hook:

```jsx
import { useRef } from "react";
```

Then create a ref inside your component:

```jsx
function MyComponent() {
  const myRef = useRef(0); // Start with value 0

  // Now myRef looks like this: { current: 0 }
}
```

### 🔍 Understanding the Ref Object

When you create a ref, you get back a simple object with one property called `current`:

```jsx
const ref = useRef("hello");
console.log(ref); // { current: "hello" }

// Read the value
console.log(ref.current); // "hello"

// Change the value
ref.current = "world";
console.log(ref.current); // "world"
```

<Callout type="warning" emoji="⚠️">
  **Important**: Unlike state, changing `ref.current` doesn't trigger a
  re-render. It's like writing in a private diary - React doesn't know or care
  when you update it!
</Callout>

---

## 🎮 Your First Ref Example: Click Counter

Let's build a simple click counter that remembers how many times you clicked, but doesn't update the UI:

```jsx
import { useRef } from "react";

export default function ClickCounter() {
  const clickCount = useRef(0);

  function handleClick() {
    // Increment the counter
    clickCount.current = clickCount.current + 1;

    // Show the count in an alert
    alert(`You've clicked ${clickCount.current} times!`);
  }

  return <button onClick={handleClick}>Click me! 🖱️</button>;
}
```

<Callout type="default" emoji="🧪">
  **Try this example**: Notice how the button text never changes, even though
  we're counting clicks! That's because refs don't cause re-renders.
</Callout>

### 🤔 Why Use a Ref Here?

You might wonder: "Why not just use a regular variable?" Here's why:

<Tabs items={['❌ Regular Variable', '✅ Ref', '🔄 State']}>
  <Tabs.Tab>
    ```jsx
    function BadCounter() {
      let count = 0; // This resets to 0 on every render!
      
      function handleClick() {
        count = count + 1;
        alert(`Count: ${count}`); // Always shows 1!
      }
      
      return <button onClick={handleClick}>Click</button>;
    }
    ```
    **Problem**: Regular variables reset on every render.
  </Tabs.Tab>
  <Tabs.Tab>
    ```jsx
    function GoodCounter() {
      const count = useRef(0); // Persists between renders!
      
      function handleClick() {
        count.current = count.current + 1;
        alert(`Count: ${count.current}`); // Shows correct count!
      }
      
      return <button onClick={handleClick}>Click</button>;
    }
    ```
    **Advantage**: Value persists, no re-renders.
  </Tabs.Tab>
  <Tabs.Tab>
    ```jsx
    function StateCounter() {
      const [count, setCount] = useState(0);
      
      function handleClick() {
        setCount(count + 1); // Triggers re-render!
        alert(`Count: ${count + 1}`);
      }
      
      return <button onClick={handleClick}>Clicked {count} times</button>;
    }
    ```
    **When to use**: When you want the UI to update.
  </Tabs.Tab>
</Tabs>

---

## ⏱️ Real-World Example: Building a Stopwatch

Let's build something more practical - a stopwatch! This will show you how refs and state work together beautifully.

### 🧠 Planning Our Stopwatch

For our stopwatch, we need to track:

- **Start time** (for rendering) → Use state ✅
- **Current time** (for rendering) → Use state ✅
- **Timer ID** (not for rendering) → Use ref ✅

### 🔨 Building Step by Step

**Step 1: Set up the basic structure**

```jsx
import { useState, useRef } from "react";

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);
  const timerRef = useRef(null);

  // We'll calculate elapsed time
  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <div className="p-6 max-w-sm mx-auto bg-white rounded-xl shadow-lg">
      <h1 className="text-2xl font-bold text-center mb-4">⏱️ Stopwatch</h1>
      <div className="text-4xl font-mono text-center mb-6">
        {secondsPassed.toFixed(3)}s
      </div>
      {/* Buttons will go here */}
    </div>
  );
}
```

**Step 2: Add the Start functionality**

```jsx
function handleStart() {
  // Record when we started
  setStartTime(Date.now());
  setNow(Date.now());

  // Clear any existing timer (in case user clicks Start multiple times)
  clearInterval(timerRef.current);

  // Start a new timer and store its ID in our ref
  timerRef.current = setInterval(() => {
    setNow(Date.now()); // Update current time every 10ms
  }, 10);
}
```

**Step 3: Add the Stop functionality**

```jsx
function handleStop() {
  // Clear the timer using the ID we stored in our ref
  clearInterval(timerRef.current);
}
```

### ✨ Complete Stopwatch Code

<Tabs items={['Final Code', 'With Styling']}>
  <Tabs.Tab>
    ```jsx
    import { useState, useRef } from 'react';

    export default function Stopwatch() {
      const [startTime, setStartTime] = useState(null);
      const [now, setNow] = useState(null);
      const timerRef = useRef(null);

      function handleStart() {
        setStartTime(Date.now());
        setNow(Date.now());

        clearInterval(timerRef.current);
        timerRef.current = setInterval(() => {
          setNow(Date.now());
        }, 10);
      }

      function handleStop() {
        clearInterval(timerRef.current);
      }

      let secondsPassed = 0;
      if (startTime != null && now != null) {
        secondsPassed = (now - startTime) / 1000;
      }

      return (
        <>
          <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
          <button onClick={handleStart}>Start</button>
          <button onClick={handleStop}>Stop</button>
        </>
      );
    }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```jsx
    import { useState, useRef } from 'react';

    export default function Stopwatch() {
      const [startTime, setStartTime] = useState(null);
      const [now, setNow] = useState(null);
      const timerRef = useRef(null);

      function handleStart() {
        setStartTime(Date.now());
        setNow(Date.now());
        clearInterval(timerRef.current);
        timerRef.current = setInterval(() => setNow(Date.now()), 10);
      }

      function handleStop() {
        clearInterval(timerRef.current);
      }

      let secondsPassed = 0;
      if (startTime != null && now != null) {
        secondsPassed = (now - startTime) / 1000;
      }

      return (
        <div className="p-8 max-w-md mx-auto bg-gradient-to-br from-blue-50 to-indigo-100 rounded-2xl shadow-xl">
          <h1 className="text-3xl font-bold text-center mb-6 text-gray-800">
            ⏱️ Stopwatch
          </h1>

          <div className="text-6xl font-mono text-center mb-8 p-4 bg-black text-green-400 rounded-lg">
            {secondsPassed.toFixed(3)}
          </div>

          <div className="flex gap-4 justify-center">
            <button
              onClick={handleStart}
              className="px-6 py-3 bg-green-500 hover:bg-green-600 text-white font-semibold rounded-lg transition-colors"
            >
              ▶️ Start
            </button>
            <button
              onClick={handleStop}
              className="px-6 py-3 bg-red-500 hover:bg-red-600 text-white font-semibold rounded-lg transition-colors"
            >
              ⏹️ Stop
            </button>
          </div>
        </div>
      );
    }
    ```

  </Tabs.Tab>
</Tabs>

### 🎯 Why This Example is Perfect

This stopwatch demonstrates the perfect use case for refs:

1. **Timer ID storage**: We need to remember the `setInterval` ID to clear it later, but we don't need to show it in the UI
2. **No unnecessary re-renders**: Storing the timer ID in state would be wasteful since it never needs to trigger a re-render
3. **Persistence**: The timer ID must survive re-renders (unlike regular variables)

<Callout type="success" emoji="🎉">
  **Key Insight**: Use refs for "behind-the-scenes" values that your component
  needs to remember but doesn't need to display!
</Callout>

---

## 🆚 Refs vs State: When to Use What?

| Feature                      | 🎯 Refs (`useRef`)                                  | 🔄 State (`useState`)         |
| ---------------------------- | --------------------------------------------------- | ----------------------------- |
| **Triggers re-render**       | ❌ No                                               | ✅ Yes                        |
| **Mutable**                  | ✅ Yes (`ref.current = newValue`)                   | ❌ No (use setter)            |
| **Persists between renders** | ✅ Yes                                              | ✅ Yes                        |
| **Initial value**            | Any value                                           | Any value                     |
| **Best for**                 | Timer IDs, counters not shown in UI, DOM references | Data that appears in your JSX |

### 🧭 Decision Guide

Ask yourself: **"Do I need to show this value in my component's JSX?"**

- **Yes** → Use `useState` 📊
- **No** → Use `useRef` 📝

---

## 🎯 Common Use Cases for Refs

### 1. 🕐 Storing Timer IDs

```jsx
const timerRef = useRef(null);
timerRef.current = setTimeout(() => {}, 1000);
// Later: clearTimeout(timerRef.current);
```

### 2. 📊 Tracking Values Without Re-renders

```jsx
const renderCountRef = useRef(0);
renderCountRef.current++; // Count renders without causing more renders!
```

### 3. 🎮 Previous Values

```jsx
const prevValueRef = useRef();
useEffect(() => {
  prevValueRef.current = currentValue;
});
```

### 4. 🏃‍♂️ Performance Counters

```jsx
const performanceRef = useRef({ clicks: 0, hovers: 0 });
performanceRef.current.clicks++; // Update without re-rendering
```

---

## 🚨 Common Pitfalls to Avoid

### ❌ Don't Read/Write Refs During Rendering

```jsx
// BAD: Don't do this!
function BadComponent() {
  const ref = useRef(0);
  ref.current = ref.current + 1; // ❌ Mutating during render
  return <div>{ref.current}</div>;
}

// GOOD: Do this instead
function GoodComponent() {
  const ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1; // ✅ Mutate in event handler
    console.log(ref.current);
  }

  return <button onClick={handleClick}>Click</button>;
}
```

### ❌ Don't Use Refs for Values You Want to Display

```jsx
// BAD: UI won't update when ref changes
function BadCounter() {
  const count = useRef(0);
  return <div>{count.current}</div>; // ❌ Won't update!
}

// GOOD: Use state for UI values
function GoodCounter() {
  const [count, setCount] = useState(0);
  return <div>{count}</div>; // ✅ Updates properly!
}
```

---

## 🎉 Key Takeaways

<Callout type="info" emoji="🎯">
**Remember these golden rules**:

1. **Refs are for remembering** values that don't affect your UI
2. **State is for values** that do affect your UI
3. **Changing refs doesn't** trigger re-renders
4. **Refs persist** between renders (unlike regular variables)
5. **Perfect for storing** timer IDs, counters, and other "behind-the-scenes" data
</Callout>

---

## 🚀 What's Next?

Now that you understand refs, you're ready to explore:

- **DOM refs** - Directly accessing DOM elements
- **forwardRef** - Passing refs to child components
- **useImperativeHandle** - Customizing ref behavior

Happy coding! 🎊
