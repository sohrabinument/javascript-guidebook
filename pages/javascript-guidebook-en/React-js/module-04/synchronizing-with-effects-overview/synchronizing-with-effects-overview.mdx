import { Callout, Tabs, Tab } from "nextra/components";

# ğŸ”„ The Complete Guide to React Effects: From Zero to Hero

_The most comprehensive guide to mastering React's useEffect hook and synchronizing with the outside world_

---

## ğŸ“‹ Table of Contents

1. ğŸ¯ What You'll Master
2. ğŸŒŸ What Are Effects? (Overview)
3. ğŸš¦ When Should You Use Effects
4. ğŸ“š Learning Effects Step by Step
5. ğŸ¯ Real-World Examples
6. ğŸ”§ Handling Effects Firing Twice in Development
7. ğŸŒ Fetching Data with Effects
8. ğŸ¤·â€â™‚ï¸ You Might Not Need an Effect
9. ğŸ”„ The Lifecycle of an Effect
10. âš¡ Effects React to Reactive Values
11. ğŸ–±ï¸ Separating Events from Effects
12. âœ‚ï¸ Removing Effect Dependencies
13. ğŸª Reusing Logic with Custom Hooks
14. ğŸ› ï¸ Advanced Patterns
15. ğŸ› Common Mistakes & Debugging
16. ğŸ“š Complete Reference

---

## ğŸ¯ What You'll Master

By the end of this comprehensive guide, you'll be able to:

- âœ… Write Effects that work correctly in all scenarios
- ğŸ› Debug Effect problems quickly and efficiently
- ğŸ§  Know when to use Effects and when to avoid them
- ğŸŒ Handle data fetching like a professional
- ğŸª Create reusable custom hooks
- âš¡ Optimize Effect performance
- ğŸ”„ Understand Effect lifecycles completely

---

## ğŸŒŸ What Are Effects? (Overview)

### ğŸ¤” What Are Effects? (The Deep Explanation)

Effects are React's way of letting you perform **side effects** in functional components. But what exactly is a "side effect"?

Think of your React component like a pure mathematical function:

```
Component(props, state) â†’ JSX
```

A pure function:

- âœ… Always returns the same output for the same input
- âœ… Doesn't modify anything outside itself
- âœ… Has no side effects

But real applications need to do "impure" things:

- ğŸŒ Fetch data from servers
- ğŸ‘‚ Listen to browser events
- ğŸ“ Update the document title
- â° Start timers
- ğŸ“Š Log analytics events

These are **side effects** because they affect something outside the pure render function.

### ğŸŒ The Two Worlds Visualization

<div style={{
  display: 'grid',
  gridTemplateColumns: '1fr auto 1fr',
  gap: '1rem',
  alignItems: 'center',
  margin: '2rem 0',
  padding: '1.5rem',
  border: '2px solid #e2e8f0',
  borderRadius: '0.75rem',
  backgroundColor: '#f8fafc'
}}>

<div
  style={{
    padding: "1.5rem",
    backgroundColor: "#dbeafe",
    borderRadius: "0.5rem",
    border: "2px solid #3b82f6",
  }}
>
  <div style={{ fontWeight: "bold", fontSize: "1.2em" }}>ğŸŒŸ REACT WORLD</div>
  <ul style={{ fontSize: "0.9rem", margin: 0 }}>
    <li>â€¢ Components</li>
    <li>â€¢ Props & State</li>
    <li>â€¢ JSX Elements</li>
    <li>â€¢ Event Handlers</li>
    <li>â€¢ Render Cycle</li>
    <li>â€¢ Virtual DOM</li>
  </ul>
  <div style={{ marginTop: "1rem", fontSize: "0.8rem", color: "#059669" }}>
    <div>âœ… Predictable</div>
    <div>âœ… Pure Functions</div>
    <div>âœ… Testable</div>
  </div>
</div>

<div
  style={{
    fontSize: "2rem",
    fontWeight: "bold",
    color: "#6366f1",
  }}
>
  ğŸŒ‰
  <br />
  useEffect
</div>

<div
  style={{
    padding: "1.5rem",
    backgroundColor: "#fef3c7",
    borderRadius: "0.5rem",
    border: "2px solid #f59e0b",
  }}
>
  <div style={{ fontWeight: "bold", fontSize: "1.2em" }}>ğŸŒ OUTSIDE WORLD</div>
  <ul style={{ fontSize: "0.9rem", margin: 0 }}>
    <li>â€¢ REST APIs</li>
    <li>â€¢ WebSocket connections</li>
    <li>â€¢ Browser APIs</li>
    <li>â€¢ LocalStorage</li>
    <li>â€¢ Timers & Intervals</li>
    <li>â€¢ Analytics Services</li>
  </ul>
</div>

</div>

### ğŸ­ The Theater Metaphor

Imagine React components as actors on a theater stage:

<Tabs items={["ğŸ¬ During Performance", "ğŸª Behind the Scenes"]}>
  <Tab>
    **During the Performance (Rendering):** - ğŸ­ Actors deliver their lines
    (JSX) - ğŸª Stage props are arranged (state/props) - ğŸ“œ Everything is
    scripted and predictable
  </Tab>
  <Tab>
    **Behind the Scenes (Effects):** - ğŸ’¡ Lighting technicians adjust spotlights
    - ğŸ”Š Sound engineers manage audio levels - ğŸª Stagehands move props between
    scenes - ğŸ« Box office sells tickets (analytics) - ğŸ”’ Security monitors the
    audience
  </Tab>
</Tabs>

Effects are like the backstage crewâ€”they make everything work, but they don't interfere with the main performance.

### ğŸ“Š Effect Categories by Purpose

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
  gap: '1rem',
  margin: '1.5rem 0'
}}>

<div style={{padding: '1rem', backgroundColor: '#f0f9ff', borderRadius: '0.5rem', border: '1px solid #0284c7'}}>
<div style={{ fontWeight: 'bold', fontSize: '1.2em' }}>ğŸŒ Data Synchronization</div>
```jsx
useEffect(() => {
  fetchUserProfile(userId);
}, [userId]);
```
</div>

<div style={{padding: '1rem', backgroundColor: '#f0fdf4', borderRadius: '0.5rem', border: '1px solid #16a34a'}}>
<div style={{ fontWeight: 'bold', fontSize: '1.2em' }}>ğŸ‘‚ Event Subscription</div>
```jsx
useEffect(() => {
  window.addEventListener('resize', handleResize);
  return () => window.removeEventListener('resize', handleResize);
}, []);
```
</div>

<div style={{padding: '1rem', backgroundColor: '#fefce8', borderRadius: '0.5rem', border: '1px solid #ca8a04'}}>
<div style={{ fontWeight: 'bold', fontSize: '1.2em' }}>â° Time-based Operations</div>
```jsx
useEffect(() => {
  const timer = setInterval(updateClock, 1000);
  return () => clearInterval(timer);
}, []);
```
</div>

</div>

---

## ğŸš¦ When Should You Use Effects

### âœ… Perfect Use Cases for Effects

#### 1. ğŸŒ Network Operations

<Tabs items={['API Data Fetching', 'WebSocket Connections', 'Real-time Subscriptions']}>
<Tab>
```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

useEffect(() => {
async function fetchUser() {
const response = await fetch(`/api/users/${userId}`);
const userData = await response.json();
setUser(userData);
}

    fetchUser();

}, [userId]);

return user ? <div>Hello, {user.name}!</div> : <div>Loading...</div>;
}

````
</Tab>
<Tab>
```jsx
function LiveChat({ roomId }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const ws = new WebSocket(`ws://chat.example.com/${roomId}`);

    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      setMessages(prev => [...prev, message]);
    };

    return () => ws.close();
  }, [roomId]);

  return (
    <div>
      {messages.map(msg => (
        <div key={msg.id}>{msg.text}</div>
      ))}
    </div>
  );
}
````

</Tab>
<Tab>
```jsx
function StockPrice({ symbol }) {
  const [price, setPrice] = useState(null);

useEffect(() => {
const subscription = stockAPI.subscribe(symbol, setPrice);
return () => subscription.unsubscribe();
}, [symbol]);

return <div>${symbol}: ${price}</div>;
}

````
</Tab>
</Tabs>

#### 2. ğŸ–±ï¸ Browser Event Management

<Tabs items={['Window Events', 'Keyboard Shortcuts', 'Scroll Tracking']}>
<Tab>
```jsx
function WindowDimensions() {
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

  useEffect(() => {
    function updateDimensions() {
      setDimensions({
        width: window.innerWidth,
        height: window.innerHeight
      });
    }

    updateDimensions(); // Set initial value
    window.addEventListener('resize', updateDimensions);

    return () => window.removeEventListener('resize', updateDimensions);
  }, []);

  return <div>{dimensions.width} x {dimensions.height}</div>;
}
````

</Tab>
<Tab>
```jsx
function KeyboardShortcuts({ onSave, onUndo }) {
  useEffect(() => {
    function handleKeyDown(event) {
      if (event.ctrlKey || event.metaKey) {
        switch (event.key) {
          case 's':
            event.preventDefault();
            onSave();
            break;
          case 'z':
            event.preventDefault();
            onUndo();
            break;
        }
      }
    }

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);

}, [onSave, onUndo]);

return null; // This component just handles shortcuts
}

````
</Tab>
<Tab>
```jsx
function ScrollTracker() {
  const [scrollY, setScrollY] = useState(0);

  useEffect(() => {
    function handleScroll() {
      setScrollY(window.scrollY);
    }

    window.addEventListener('scroll', handleScroll, { passive: true });
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  return (
    <div className={`scroll-indicator ${scrollY > 100 ? 'scrolled' : ''}`}>
      Scrolled: {scrollY}px
    </div>
  );
}
````

</Tab>
</Tabs>

#### 3. â° Time-Based Operations

<Tabs items={['Countdown Timer', 'Auto-save with Debouncing']}>
<Tab>
```jsx
function CountdownTimer({ targetDate }) {
  const [timeLeft, setTimeLeft] = useState(0);

useEffect(() => {
function updateCountdown() {
const now = new Date().getTime();
const target = new Date(targetDate).getTime();
const difference = target - now;

      setTimeLeft(Math.max(0, difference));
    }

    updateCountdown(); // Initial calculation
    const interval = setInterval(updateCountdown, 1000);

    return () => clearInterval(interval);

}, [targetDate]);

const days = Math.floor(timeLeft / (1000 _ 60 _ 60 _ 24));
const hours = Math.floor((timeLeft % (1000 _ 60 _ 60 _ 24)) / (1000 _ 60 _ 60));
const minutes = Math.floor((timeLeft % (1000 _ 60 _ 60)) / (1000 _ 60));
const seconds = Math.floor((timeLeft % (1000 _ 60)) / 1000);

return (

<div className="countdown">
  {days}d {hours}h {minutes}m {seconds}s
</div>
); }

````
</Tab>
<Tab>
```jsx
function AutoSaveEditor({ documentId, initialContent }) {
  const [content, setContent] = useState(initialContent);
  const [saveStatus, setSaveStatus] = useState('saved');

  useEffect(() => {
    if (content === initialContent) return; // Don't save unchanged content

    setSaveStatus('saving...');

    const timeoutId = setTimeout(async () => {
      try {
        await saveDocument(documentId, content);
        setSaveStatus('saved âœ…');
      } catch (error) {
        setSaveStatus('save failed âŒ');
      }
    }, 2000); // Wait 2 seconds after user stops typing

    return () => clearTimeout(timeoutId);
  }, [content, documentId, initialContent]);

  return (
    <div>
      <div>Status: {saveStatus}</div>
      <textarea
        value={content}
        onChange={(e) => {
          setContent(e.target.value);
          setSaveStatus('typing...');
        }}
      />
    </div>
  );
}
````

</Tab>
</Tabs>

### âŒ When NOT to Use Effects

<Callout type="warning" emoji="âš ï¸">
  **Common Anti-Pattern Alert!** Many developers overuse Effects. Here's when to
  avoid them:
</Callout>

#### 1. ğŸ§® Calculating Values from Props/State

<Tabs items={['âŒ Wrong Way', 'âœ… Right Way', 'âœ… For Expensive Calculations']}>
<Tab>
```jsx
// âŒ DON'T DO THIS - Unnecessary Effect
function ExpensiveCalculation({ items, taxRate }) {
  const [total, setTotal] = useState(0);

useEffect(() => {
const subtotal = items.reduce((sum, item) => sum + item.price, 0);
const totalWithTax = subtotal \* (1 + taxRate);
setTotal(totalWithTax);
}, [items, taxRate]);

return <div>Total: ${total}</div>;
}

````
</Tab>
<Tab>
```jsx
// âœ… DO THIS INSTEAD - Calculate during render
function ExpensiveCalculation({ items, taxRate }) {
  // This calculation happens during render - no Effect needed!
  const subtotal = items.reduce((sum, item) => sum + item.price, 0);
  const total = subtotal * (1 + taxRate);

  return <div>Total: ${total}</div>;
}
````

</Tab>
<Tab>
```jsx
// âœ… FOR EXPENSIVE CALCULATIONS - Use useMemo
function ExpensiveCalculation({ items, taxRate }) {
  const total = useMemo(() => {
    console.log('Calculating total...'); // Only runs when inputs change
    const subtotal = items.reduce((sum, item) => sum + item.price, 0);
    return subtotal * (1 + taxRate);
  }, [items, taxRate]);

return <div>Total: ${total}</div>;
}

````
</Tab>
</Tabs>

#### 2. ğŸ¨ Transforming Data for Rendering

<Tabs items={['âŒ Wrong Way', 'âœ… Right Way', 'âœ… With Optimization']}>
<Tab>
```jsx
// âŒ DON'T DO THIS
function SearchResults({ items, searchTerm }) {
  const [filteredItems, setFilteredItems] = useState([]);

  useEffect(() => {
    const filtered = items.filter(item =>
      item.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
    setFilteredItems(filtered);
  }, [items, searchTerm]);

  return (
    <ul>
      {filteredItems.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
````

</Tab>
<Tab>
```jsx
// âœ… DO THIS INSTEAD
function SearchResults({ items, searchTerm }) {
  // Filter during render - no Effect needed!
  const filteredItems = items.filter(item =>
    item.name.toLowerCase().includes(searchTerm.toLowerCase())
  );

return (

<ul>
  {filteredItems.map((item) => (
    <li key={item.id}>{item.name}</li>
  ))}
</ul>
); }

````
</Tab>
<Tab>
```jsx
// âœ… FOR EXPENSIVE FILTERING - Use useMemo
function SearchResults({ items, searchTerm }) {
  const filteredItems = useMemo(() => {
    return items.filter(item =>
      item.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [items, searchTerm]);

  return (
    <ul>
      {filteredItems.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
````

</Tab>
</Tabs>

---

## ğŸ“š Learning Effects Step by Step

### Step 1: Your First Effect

Let's start with the absolute basics:

```jsx
import { useEffect, useState } from "react";

function MyFirstEffect() {
  const [count, setCount] = useState(0);

  // This Effect runs after every render
  useEffect(() => {
    console.log("Effect ran! Count is:", count);
  });

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

<div style={{
  padding: '1rem',
  backgroundColor: '#f0f9ff',
  borderRadius: '0.5rem',
  border: '1px solid #0284c7',
  margin: '1rem 0'
}}>

**ğŸ” What happens when you run this?**

1. Component renders â†’ Shows "Count: 0"
2. Effect runs â†’ Logs "Effect ran! Count is: 0"
3. You click button â†’ `setCount(1)` â†’ Component re-renders
4. Effect runs again â†’ Logs "Effect ran! Count is: 1"

**ğŸ’¡ Key Learning**: By default, Effects run after every render!

</div>

### Step 2: Controlling When Effects Run

Running after every render is usually too much. Here's how to control it:

#### Pattern A: Run Only Once (On Mount)

```jsx
function RunOnce() {
  const [data, setData] = useState(null);

  useEffect(() => {
    console.log("This only runs once when component mounts!");

    // Simulate API call
    setTimeout(() => {
      setData("Data loaded!");
    }, 2000);
  }, []); // â† Empty dependency array

  return <div>{data || "Loading..."}</div>;
}
```

<Callout type="info" emoji="ğŸ“">
  **The empty array `[]` means**: "This Effect has no dependencies, so run it
  only once when the component mounts."
</Callout>

#### Pattern B: Run When Specific Values Change

```jsx
function RunOnChange({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    console.log("User ID changed to:", userId);

    // Fetch new user data
    fetchUser(userId).then(setUser);
  }, [userId]); // â† Runs when userId changes

  return <div>{user ? `Hello, ${user.name}!` : "Loading user..."}</div>;
}
```

<Callout type="info" emoji="ğŸ”„">
  **The dependency array `[userId]` means**: "Run this Effect whenever `userId`
  changes."
</Callout>

### Step 3: Cleanup (The Most Important Concept!)

Many Effects need to "clean up" after themselves. This prevents memory leaks and bugs.

#### Basic Cleanup Example

```jsx
function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    console.log("âš¡ Setting up timer");

    // Setup: Start the timer
    const intervalId = setInterval(() => {
      setSeconds((prevSeconds) => prevSeconds + 1);
    }, 1000);

    // Cleanup function: Stop the timer
    return () => {
      console.log("ğŸ§¹ Cleaning up timer");
      clearInterval(intervalId);
    };
  }, []); // Run once

  return <div>Timer: {seconds} seconds</div>;
}
```

<div style={{
  padding: '1rem',
  backgroundColor: '#fef3c7',
  borderRadius: '0.5rem',
  border: '1px solid #f59e0b',
  margin: '1rem 0'
}}>

**ğŸ” What happens here?**

1. Component mounts â†’ "Setting up timer" â†’ Timer starts
2. Every second â†’ Timer increments `seconds`
3. Component unmounts â†’ "Cleaning up timer" â†’ Timer stops

**âš ï¸ Without cleanup**: Timer would run forever, even after component is gone! ğŸ’¥

</div>

---

## ğŸ¯ Real-World Examples

### Example 1: Complete Weather App

```jsx
function WeatherApp() {
  const [location, setLocation] = useState("");
  const [weather, setWeather] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [units, setUnits] = useState("celsius");

  // Effect 1: Fetch weather data
  useEffect(() => {
    if (!location.trim()) {
      setWeather(null);
      return;
    }

    setLoading(true);
    setError(null);

    // Use AbortController to cancel requests
    const controller = new AbortController();

    async function fetchWeather() {
      try {
        const response = await fetch(
          `/api/weather?location=${encodeURIComponent(
            location
          )}&units=${units}`,
          { signal: controller.signal }
        );

        if (!response.ok) {
          throw new Error(`Weather service error: ${response.status}`);
        }

        const weatherData = await response.json();
        setWeather(weatherData);
      } catch (err) {
        if (err.name !== "AbortError") {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    }

    fetchWeather();

    // Cleanup: Cancel request if location or units change
    return () => {
      controller.abort();
    };
  }, [location, units]);

  // Effect 2: Update document title
  useEffect(() => {
    if (weather) {
      document.title = `${weather.temperature}Â° in ${location} - Weather App`;
    } else {
      document.title = "Weather App";
    }

    // Cleanup: Reset title when component unmounts
    return () => {
      document.title = "My App";
    };
  }, [weather, location]);

  // Effect 3: Save user preferences
  useEffect(() => {
    localStorage.setItem("weatherApp_units", units);
  }, [units]);

  // Effect 4: Load saved preferences on mount
  useEffect(() => {
    const savedUnits = localStorage.getItem("weatherApp_units");
    if (savedUnits) {
      setUnits(savedUnits);
    }
  }, []); // Run once on mount

  return (
    <div className="weather-app">
      <h1>ğŸŒ¤ï¸ Weather App</h1>

      <div className="controls">
        <input
          type="text"
          value={location}
          onChange={(e) => setLocation(e.target.value)}
          placeholder="Enter city name..."
        />

        <select value={units} onChange={(e) => setUnits(e.target.value)}>
          <option value="celsius">Celsius</option>
          <option value="fahrenheit">Fahrenheit</option>
        </select>
      </div>

      {loading && <div className="loading">ğŸŒ€ Loading weather...</div>}

      {error && <div className="error">âŒ Error: {error}</div>}

      {weather && !loading && (
        <div className="weather-display">
          <h2>{location}</h2>
          <div className="temperature">
            {weather.temperature}Â°{units === "celsius" ? "C" : "F"}
          </div>
          <div className="condition">{weather.condition}</div>
          <div className="details">
            <p>Humidity: {weather.humidity}%</p>
            <p>Wind: {weather.windSpeed} mph</p>
          </div>
        </div>
      )}
    </div>
  );
}
```

---

## ğŸ”§ Handling Effects Firing Twice in Development

<Callout type="info" emoji="ğŸ§ª">
  In React Strict Mode, Effects run twice on mount to help you catch bugs. This
  only happens in development!
</Callout>

```jsx
useEffect(() => {
  // This will run twice in Strict Mode (dev only)
  console.log("Effect running...");

  return () => {
    // Cleanup runs twice too!
    console.log("Cleanup running...");
  };
}, []);
```

**Why does React do this?** It helps you find Effects that aren't properly cleaned up. If your Effect causes problems when run twice, you probably need better cleanup!

<Callout type="warning" emoji="âš ï¸">
  Add cleanup functions to avoid memory leaks or duplicate subscriptions.
</Callout>

---

## ğŸŒ Fetching Data with Effects

Fetching data is a very common use case for effects. Here's how you do it safely:

<Tabs items={['Basic Pattern', 'With AbortController', 'With Custom Hook']}>
<Tab>
```jsx
useEffect(() => {
  let ignore = false;
  
  fetch('/api/data')
    .then(res => res.json())
    .then(data => {
      if (!ignore) {
        setData(data);
      }
    });
    
  return () => {
    ignore = true;
  };
}, []);
```
</Tab>
<Tab>
```jsx
useEffect(() => {
  const controller = new AbortController();
  
  async function fetchData() {
    try {
      const response = await fetch('/api/data', {
        signal: controller.signal
      });
      const data = await response.json();
      setData(data);
    } catch (error) {
      if (error.name !== 'AbortError') {
        setError(error.message);
      }
    }
  }
  
  fetchData();
  
  return () => {
    controller.abort();
  };
}, []);
```
</Tab>
<Tab>
```jsx
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

useEffect(() => {
const controller = new AbortController();

    async function fetchData() {
      try {
        setLoading(true);
        const response = await fetch(url, {
          signal: controller.signal
        });
        const result = await response.json();
        setData(result);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    }

    fetchData();

    return () => controller.abort();

}, [url]);

return { data, loading, error };
}

// Usage:
function MyComponent() {
const { data, loading, error } = useFetch('/api/users');

if (loading) return <div>Loading...</div>;
if (error) return <div>Error: {error}</div>;
return <div>{JSON.stringify(data)}</div>;
}

````
</Tab>
</Tabs>

<Callout type="warning" emoji="âš ï¸">
Always clean up async effects to avoid setting state on unmounted components!
</Callout>

---

## ğŸ¤·â€â™‚ï¸ You Might Not Need an Effect

If you're just transforming data for display, use rendering or memoization instead of Effects.

<div style={{
  display: 'grid',
  gridTemplateColumns: '1fr 1fr',
  gap: '1rem',
  margin: '1rem 0'
}}>

<div style={{padding: '1rem', backgroundColor: '#fef2f2', borderRadius: '0.5rem', border: '1px solid #ef4444'}}>
<div style={{ fontWeight: 'bold', fontSize: '1.2em' }}>âŒ Don't do this:</div>
```jsx
const [filtered, setFiltered] = useState([]);

useEffect(() => {
  setFiltered(items.filter(item => item.active));
}, [items]);
````

</div>

<div style={{padding: '1rem', backgroundColor: '#f0fdf4', borderRadius: '0.5rem', border: '1px solid #22c55e'}}>
<div style={{ fontWeight: 'bold', fontSize: '1.2em' }}>âœ… Do this instead:</div>
```jsx
// Calculate during render
const filtered = items.filter(item => item.active);

// Or use useMemo for expensive calculations
const filtered = useMemo(() =>
items.filter(item => item.active), [items]
);

````
</div>

</div>

<Callout type="info" emoji="ğŸ’¡">
Effects are for side effects, not for calculations you can do in render!
</Callout>

---
# ğŸ”„ The Lifecycle of an Effect (Continued)

<div style={{
  display: 'flex',
  justifyContent: 'space-around',
  alignItems: 'center',
  padding: '2rem',
  backgroundColor: '#f8fafc',
  borderRadius: '0.75rem',
  border: '2px solid #e2e8f0',
  margin: '1.5rem 0'
}}>

<div style={{textAlign: 'center'}}>
<div style={{fontSize: '2rem', marginBottom: '0.5rem'}}>ğŸ—ï¸</div>
<div><strong>Mount</strong></div>
<div style={{fontSize: '0.9rem', color: '#6b7280'}}>Effect runs after first render</div>
</div>

<div style={{fontSize: '1.5rem', color: '#6366f1'}}>â†’</div>

<div style={{textAlign: 'center'}}>
<div style={{fontSize: '2rem', marginBottom: '0.5rem'}}>ğŸ”„</div>
<div><strong>Update</strong></div>
<div style={{fontSize: '0.9rem', color: '#6b7280'}}>Effect runs if dependencies change</div>
</div>

<div style={{fontSize: '1.5rem', color: '#6366f1'}}>â†’</div>

<div style={{textAlign: 'center'}}>
<div style={{fontSize: '2rem', marginBottom: '0.5rem'}}>ğŸ§¹</div>
<div><strong>Unmount</strong></div>
<div style={{fontSize: '0.9rem', color: '#6b7280'}}>Cleanup function runs</div>
</div>

</div>

### ğŸ“Š Detailed Effect Timeline

Here's what happens during each phase:

```jsx
function EffectLifecycleDemo({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    console.log('ğŸ—ï¸ SETUP: Effect is starting');

    // This runs on mount and when userId changes
    async function fetchUser() {
      console.log('ğŸ“¡ FETCHING: Getting user data for ID:', userId);

      try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        setUser(userData);
        console.log('âœ… SUCCESS: User data loaded');
      } catch (error) {
        console.log('âŒ ERROR: Failed to load user');
      }
    }

    fetchUser();

    // Cleanup function
    return () => {
      console.log('ğŸ§¹ CLEANUP: Effect is cleaning up');
      // Cancel any ongoing requests, clear timers, etc.
    };
  }, [userId]); // Dependencies array

  return (
    <div>
      {user ? `Hello, ${user.name}!` : 'Loading...'}
    </div>
  );
}
````

<div style={{
  padding: '1.5rem',
  backgroundColor: '#f0f9ff',
  borderRadius: '0.5rem',
  border: '1px solid #0284c7',
  margin: '1rem 0'
}}>

**ğŸ” What you'll see in the console:**

1. **First render (userId = "123")**:

   - ğŸ—ï¸ SETUP: Effect is starting
   - ğŸ“¡ FETCHING: Getting user data for ID: 123
   - âœ… SUCCESS: User data loaded

2. **Props change (userId = "456")**:

   - ğŸ§¹ CLEANUP: Effect is cleaning up
   - ğŸ—ï¸ SETUP: Effect is starting
   - ğŸ“¡ FETCHING: Getting user data for ID: 456
   - âœ… SUCCESS: User data loaded

3. **Component unmounts**:
   - ğŸ§¹ CLEANUP: Effect is cleaning up

</div>

---

## âš¡ Effects React to Reactive Values

### ğŸ¯ Understanding Dependencies

Effects "react" to **reactive values** - values that can change over time and come from the component scope.

#### ğŸ” What Are Reactive Values?

<div style={{
  display: 'grid',
  gridTemplateColumns: '1fr 1fr',
  gap: '1rem',
  margin: '1rem 0'
}}>

<div
  style={{
    padding: "1rem",
    backgroundColor: "#f0fdf4",
    borderRadius: "0.5rem",
    border: "1px solid #22c55e",
  }}
>
  <div style={{ fontWeight: "bold", fontSize: "1.2em" }}>
    âœ… Reactive Values (Must be in dependencies)
  </div>
  - State variables (`useState`) - Props from parent components - Context values
  (`useContext`) - Values derived from reactive values - Ref values that change (not
  the ref itself)
</div>

<div
  style={{
    padding: "1rem",
    backgroundColor: "#fef3c7",
    borderRadius: "0.5rem",
    border: "1px solid #f59e0b",
  }}
>
  <div style={{ fontWeight: "bold", fontSize: "1.2em" }}>
    âš ï¸ Non-Reactive Values (Don't need dependencies)
  </div>
  - Functions defined outside components - Constants defined outside components -
  Ref objects (`useRef()`) - Static values that never change
</div>

</div>

#### ğŸ§ª Reactive Values Example

```jsx
const STATIC_CONFIG = { apiVersion: "v1" }; // Non-reactive

function UserProfile({ userId, theme }) {
  // userId, theme are reactive (props)
  const [user, setUser] = useState(null); // user, setUser are reactive
  const [loading, setLoading] = useState(false); // loading, setLoading are reactive
  const retryCountRef = useRef(0); // retryCountRef is non-reactive (ref object)

  // This value is derived from reactive values, so it's reactive too
  const shouldShowLoader = loading && user === null;

  useEffect(() => {
    async function fetchUser() {
      setLoading(true); // setLoading is stable, but good practice to include

      try {
        // userId is reactive - must be in dependencies
        // STATIC_CONFIG is non-reactive - doesn't need to be in dependencies
        const response = await fetch(
          `/api/${STATIC_CONFIG.apiVersion}/users/${userId}`
        );
        const userData = await response.json();

        setUser(userData); // setUser is stable, but good practice to include
        retryCountRef.current = 0; // Ref mutation - doesn't need to be in dependencies
      } catch (error) {
        console.error("Failed to fetch user");
        retryCountRef.current += 1;
      } finally {
        setLoading(false);
      }
    }

    fetchUser();
  }, [userId]); // Only userId needs to be here!

  // Another effect that depends on multiple reactive values
  useEffect(() => {
    if (shouldShowLoader) {
      document.body.classList.add(`loading-${theme}`);
    } else {
      document.body.classList.remove(`loading-${theme}`);
    }

    return () => {
      document.body.classList.remove(`loading-${theme}`);
    };
  }, [shouldShowLoader, theme]); // Both are reactive

  return (
    <div className={theme}>{user ? `Hello, ${user.name}!` : "Loading..."}</div>
  );
}
```

### ğŸ”§ ESLint Plugin for Dependencies

React provides an ESLint plugin that catches dependency issues automatically:

```bash
npm install eslint-plugin-react-hooks
```

```json
// .eslintrc.js
{
  "plugins": ["react-hooks"],
  "rules": {
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

<Callout type="info" emoji="ğŸ› ï¸">
  This plugin will warn you when you're missing dependencies or including
  unnecessary ones!
</Callout>

---

## ğŸ–±ï¸ Separating Events from Effects

### ğŸ¤” The Problem: Event Handlers vs Effects

Sometimes you want to respond to user actions (events) but also sync with external systems (effects). Here's how to separate these concerns:

#### âŒ Problematic Pattern

```jsx
function ChatRoom({ roomId, theme }) {
  const [message, setMessage] = useState("");

  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();

    connection.on("message", (msg) => {
      // âŒ Problem: This logs every time theme changes!
      console.log("New message in", theme, "theme:", msg);
    });

    return () => connection.disconnect();
  }, [roomId, theme]); // theme is needed because it's used inside

  // ... rest of component
}
```

#### âœ… Solution: Extract Event Logic

```jsx
import { useEffectEvent } from "react"; // Experimental API

function ChatRoom({ roomId, theme }) {
  const [message, setMessage] = useState("");

  // Extract the event logic that shouldn't re-run the effect
  const onMessage = useEffectEvent((msg) => {
    console.log("New message in", theme, "theme:", msg);
  });

  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();

    connection.on("message", onMessage); // This can use latest theme without re-running effect

    return () => connection.disconnect();
  }, [roomId]); // Only roomId needed!

  // ... rest of component
}
```

#### ğŸ”„ Alternative: Manual Event Handling

If `useEffectEvent` isn't available, handle events manually:

```jsx
function ChatRoom({ roomId, theme }) {
  const [messages, setMessages] = useState([]);
  const themeRef = useRef(theme);

  // Keep ref updated
  useEffect(() => {
    themeRef.current = theme;
  });

  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();

    connection.on("message", (msg) => {
      // Use ref to get latest theme without adding it to dependencies
      console.log("New message in", themeRef.current, "theme:", msg);
      setMessages((prev) => [...prev, msg]);
    });

    return () => connection.disconnect();
  }, [roomId]); // Only roomId affects the connection

  return (
    <div className={theme}>
      {messages.map((msg) => (
        <div key={msg.id}>{msg.text}</div>
      ))}
    </div>
  );
}
```

---

## âœ‚ï¸ Removing Effect Dependencies

### ğŸ¯ Strategies to Minimize Dependencies

Having fewer dependencies makes Effects more stable and performant. Here are proven techniques:

#### 1. ğŸ—ï¸ Move Non-Reactive Values Outside

```jsx
// âŒ Before: function inside component
function Timer() {
  const [count, setCount] = useState(0);

  const getRandomDelay = () => Math.random() * 1000 + 500;

  useEffect(() => {
    const timer = setTimeout(() => {
      setCount((c) => c + 1);
    }, getRandomDelay()); // getRandomDelay recreated every render!

    return () => clearTimeout(timer);
  }, [getRandomDelay]); // Unnecessary dependency

  return <div>Count: {count}</div>;
}
```

```jsx
// âœ… After: move function outside
const getRandomDelay = () => Math.random() * 1000 + 500;

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setTimeout(() => {
      setCount((c) => c + 1);
    }, getRandomDelay()); // No dependency needed!

    return () => clearTimeout(timer);
  }, []); // Much cleaner!

  return <div>Count: {count}</div>;
}
```

#### 2. ğŸ”„ Use Functional State Updates

```jsx
// âŒ Before: depends on current state
function Counter({ step }) {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      setCount(count + step); // Depends on count!
    }, 1000);

    return () => clearInterval(timer);
  }, [count, step]); // Effect runs every time count changes

  return <div>Count: {count}</div>;
}
```

```jsx
// âœ… After: functional update removes count dependency
function Counter({ step }) {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      setCount((prevCount) => prevCount + step); // No count dependency!
    }, 1000);

    return () => clearInterval(timer);
  }, [step]); // Only runs when step changes

  return <div>Count: {count}</div>;
}
```

#### 3. ğŸª Use useCallback for Function Dependencies

```jsx
// âŒ Before: function recreated every render
function SearchResults({ query, sortBy }) {
  const [results, setResults] = useState([]);

  const searchFunction = async (searchTerm, sort) => {
    const response = await fetch(`/api/search?q=${searchTerm}&sort=${sort}`);
    return response.json();
  };

  useEffect(() => {
    searchFunction(query, sortBy).then(setResults);
  }, [searchFunction, query, sortBy]); // searchFunction changes every render!

  return <div>{results.length} results</div>;
}
```

```jsx
// âœ… After: memoize the function
function SearchResults({ query, sortBy }) {
  const [results, setResults] = useState([]);

  const searchFunction = useCallback(async (searchTerm, sort) => {
    const response = await fetch(`/api/search?q=${searchTerm}&sort=${sort}`);
    return response.json();
  }, []); // No dependencies - function is stable

  useEffect(() => {
    searchFunction(query, sortBy).then(setResults);
  }, [searchFunction, query, sortBy]); // searchFunction won't cause re-runs

  return <div>{results.length} results</div>;
}
```

#### 4. ğŸ­ Extract Custom Hooks

```jsx
// âœ… Clean separation of concerns
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!url) return;

    const controller = new AbortController();

    async function fetchData() {
      setLoading(true);
      setError(null);

      try {
        const response = await fetch(url, { signal: controller.signal });
        const result = await response.json();
        setData(result);
      } catch (err) {
        if (err.name !== "AbortError") {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    }

    fetchData();

    return () => controller.abort();
  }, [url]);

  return { data, loading, error };
}

// Usage is much cleaner
function UserProfile({ userId }) {
  const { data: user, loading, error } = useApi(`/api/users/${userId}`);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  return <div>Hello, {user?.name}!</div>;
}
```

---

## ğŸª Reusing Logic with Custom Hooks

Custom hooks are the key to reusing Effect logic across components. Here are some powerful patterns:

### ğŸŒ useApi - Complete Data Fetching Hook

```jsx
function useApi(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const { skip = false, onSuccess, onError, transform } = options;

  const refresh = useCallback(async () => {
    if (!url || skip) return;

    const controller = new AbortController();

    try {
      setLoading(true);
      setError(null);

      const response = await fetch(url, {
        signal: controller.signal,
        ...options.fetchOptions,
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      let result = await response.json();

      // Optional data transformation
      if (transform) {
        result = transform(result);
      }

      setData(result);
      onSuccess?.(result);
    } catch (err) {
      if (err.name !== "AbortError") {
        setError(err.message);
        onError?.(err);
      }
    } finally {
      setLoading(false);
    }

    return () => controller.abort();
  }, [url, skip, onSuccess, onError, transform]);

  useEffect(() => {
    refresh();
  }, [refresh]);

  return {
    data,
    loading,
    error,
    refresh,
  };
}

// Usage examples
function UserList() {
  const {
    data: users,
    loading,
    error,
    refresh,
  } = useApi("/api/users", {
    transform: (data) => data.sort((a, b) => a.name.localeCompare(b.name)),
    onSuccess: (users) => console.log(`Loaded ${users.length} users`),
    onError: (error) => console.error("Failed to load users:", error),
  });

  return (
    <div>
      <button onClick={refresh}>Refresh</button>
      {loading && <div>Loading users...</div>}
      {error && <div>Error: {error}</div>}
      {users?.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
}
```

### ğŸ‘‚ useEventListener - Universal Event Hook

```jsx
function useEventListener(eventName, handler, element = window, options = {}) {
  // Create a ref that stores handler
  const savedHandler = useRef();

  // Update ref.current value if handler changes
  useEffect(() => {
    savedHandler.current = handler;
  }, [handler]);

  useEffect(() => {
    // Make sure element supports addEventListener
    const isSupported = element && element.addEventListener;
    if (!isSupported) return;

    // Create event listener that calls handler function stored in ref
    const eventListener = (event) => savedHandler.current(event);

    // Add event listener
    element.addEventListener(eventName, eventListener, options);

    // Remove event listener on cleanup
    return () => {
      element.removeEventListener(eventName, eventListener, options);
    };
  }, [eventName, element, options]);
}

// Usage examples
function WindowSizeTracker() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEventListener("resize", () => {
    setWindowSize({
      width: window.innerWidth,
      height: window.innerHeight,
    });
  });

  return (
    <div>
      {windowSize.width} x {windowSize.height}
    </div>
  );
}

function EscapeKeyHandler({ onEscape }) {
  useEventListener("keydown", (event) => {
    if (event.key === "Escape") {
      onEscape();
    }
  });

  return null;
}
```

### â° useInterval - Declarative Intervals

```jsx
function useInterval(callback, delay) {
  const savedCallback = useRef();

  // Remember the latest callback
  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  // Set up the interval
  useEffect(() => {
    if (delay === null) return; // Allow pausing

    const tick = () => savedCallback.current();
    const id = setInterval(tick, delay);

    return () => clearInterval(id);
  }, [delay]);
}

// Usage
function Timer() {
  const [count, setCount] = useState(0);
  const [isRunning, setIsRunning] = useState(true);

  useInterval(
    () => {
      setCount((count) => count + 1);
    },
    isRunning ? 1000 : null
  ); // Pass null to pause

  return (
    <div>
      <div>Count: {count}</div>
      <button onClick={() => setIsRunning(!isRunning)}>
        {isRunning ? "Pause" : "Start"}
      </button>
    </div>
  );
}
```

### ğŸ’¾ useLocalStorage - Persistent State

```jsx
function useLocalStorage(key, initialValue) {
  // Get from local storage then parse stored json or return initialValue
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that persists the new value to localStorage
  const setValue = useCallback(
    (value) => {
      try {
        // Allow value to be a function so we have the same API as useState
        const valueToStore =
          value instanceof Function ? value(storedValue) : value;

        // Save state
        setStoredValue(valueToStore);

        // Save to local storage
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      } catch (error) {
        console.warn(`Error setting localStorage key "${key}":`, error);
      }
    },
    [key, storedValue]
  );

  return [storedValue, setValue];
}

// Usage
function Settings() {
  const [theme, setTheme] = useLocalStorage("theme", "light");
  const [language, setLanguage] = useLocalStorage("language", "en");

  return (
    <div>
      <select value={theme} onChange={(e) => setTheme(e.target.value)}>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
      </select>

      <select value={language} onChange={(e) => setLanguage(e.target.value)}>
        <option value="en">English</option>
        <option value="es">Spanish</option>
      </select>

      <p>Settings are automatically saved!</p>
    </div>
  );
}
```

---

## ğŸ› ï¸ Advanced Patterns

### ğŸ”„ useReducer + useEffect for Complex State

```jsx
const initialState = {
  data: null,
  loading: false,
  error: null,
  retryCount: 0,
};

function apiReducer(state, action) {
  switch (action.type) {
    case "FETCH_START":
      return {
        ...state,
        loading: true,
        error: null,
      };
    case "FETCH_SUCCESS":
      return {
        ...state,
        loading: false,
        data: action.payload,
        retryCount: 0,
      };
    case "FETCH_ERROR":
      return {
        ...state,
        loading: false,
        error: action.payload,
        retryCount: state.retryCount + 1,
      };
    case "RETRY":
      return {
        ...state,
        error: null,
      };
    default:
      return state;
  }
}

function useApiWithRetry(url, maxRetries = 3) {
  const [state, dispatch] = useReducer(apiReducer, initialState);

  useEffect(() => {
    if (!url) return;

    const controller = new AbortController();

    async function fetchData() {
      dispatch({ type: "FETCH_START" });

      try {
        const response = await fetch(url, { signal: controller.signal });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        dispatch({ type: "FETCH_SUCCESS", payload: data });
      } catch (error) {
        if (error.name !== "AbortError") {
          dispatch({ type: "FETCH_ERROR", payload: error.message });
        }
      }
    }

    fetchData();

    return () => controller.abort();
  }, [url, state.retryCount]); // Re-run when retrying

  // Auto-retry on error (with exponential backoff)
  useEffect(() => {
    if (state.error && state.retryCount < maxRetries) {
      const delay = Math.pow(2, state.retryCount) * 1000; // 1s, 2s, 4s...

      const timer = setTimeout(() => {
        dispatch({ type: "RETRY" });
      }, delay);

      return () => clearTimeout(timer);
    }
  }, [state.error, state.retryCount, maxRetries]);

  const retry = useCallback(() => {
    dispatch({ type: "RETRY" });
  }, []);

  return {
    ...state,
    retry,
  };
}
```

### ğŸŒŠ useWebSocket - Real-time Connection

```jsx
function useWebSocket(url, options = {}) {
  const [socket, setSocket] = useState(null);
  const [lastMessage, setLastMessage] = useState(null);
  const [readyState, setReadyState] = useState(WebSocket.CONNECTING);

  const {
    onOpen,
    onClose,
    onMessage,
    onError,
    shouldReconnect = true,
    reconnectAttempts = 5,
    reconnectInterval = 3000,
  } = options;

  useEffect(() => {
    if (!url) return;

    let reconnectCount = 0;
    let reconnectTimer;

    function connect() {
      const ws = new WebSocket(url);
      setSocket(ws);
      setReadyState(WebSocket.CONNECTING);

      ws.onopen = (event) => {
        setReadyState(WebSocket.OPEN);
        reconnectCount = 0; // Reset on successful connection
        onOpen?.(event);
      };

      ws.onclose = (event) => {
        setReadyState(WebSocket.CLOSED);
        onClose?.(event);

        // Attempt to reconnect
        if (shouldReconnect && reconnectCount < reconnectAttempts) {
          reconnectCount++;
          console.log(
            `WebSocket reconnecting... (${reconnectCount}/${reconnectAttempts})`
          );

          reconnectTimer = setTimeout(() => {
            connect();
          }, reconnectInterval);
        }
      };

      ws.onmessage = (event) => {
        const message = JSON.parse(event.data);
        setLastMessage(message);
        onMessage?.(message);
      };

      ws.onerror = (event) => {
        setReadyState(WebSocket.CLOSED);
        onError?.(event);
      };
    }

    connect();

    return () => {
      clearTimeout(reconnectTimer);
      if (socket) {
        socket.close();
      }
    };
  }, [url]);

  const sendMessage = useCallback(
    (message) => {
      if (socket && readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify(message));
      }
    },
    [socket, readyState]
  );

  return {
    sendMessage,
    lastMessage,
    readyState,
    socket,
  };
}

// Usage
function LiveChat({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState("");

  const { sendMessage, lastMessage, readyState } = useWebSocket(
    `ws://localhost:8080/chat/${roomId}`,
    {
      onMessage: (message) => {
        setMessages((prev) => [...prev, message]);
      },
      shouldReconnect: true,
    }
  );

  const handleSendMessage = () => {
    if (inputValue.trim()) {
      sendMessage({
        type: "chat",
        text: inputValue,
        timestamp: new Date().toISOString(),
      });
      setInputValue("");
    }
  };

  const connectionStatus = {
    [WebSocket.CONNECTING]: "Connecting...",
    [WebSocket.OPEN]: "Connected",
    [WebSocket.CLOSING]: "Closing...",
    [WebSocket.CLOSED]: "Disconnected",
  }[readyState];

  return (
    <div>
      <div>Status: {connectionStatus}</div>
      <div style={{ height: "300px", overflowY: "auto" }}>
        {messages.map((msg, index) => (
          <div key={index}>{msg.text}</div>
        ))}
      </div>
      <input
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        onKeyPress={(e) => e.key === "Enter" && handleSendMessage()}
        disabled={readyState !== WebSocket.OPEN}
      />
      <button
        onClick={handleSendMessage}
        disabled={readyState !== WebSocket.OPEN}
      >
        Send
      </button>
    </div>
  );
}
```

---

## ğŸ› Common Mistakes & Debugging

### âŒ Mistake 1: Missing Dependencies

```jsx
// âŒ WRONG - Missing userId dependency
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, []); // Missing userId!

  return <div>{user?.name}</div>;
}
```

**ğŸ› Problem**: Effect only runs once, ignoring `userId` changes.

**âœ… Fix**: Add all reactive values to dependencies.

```jsx
// âœ… CORRECT
useEffect(() => {
  fetchUser(userId).then(setUser);
}, [userId]); // Include userId
```

### âŒ Mistake 2: Infinite Re-renders

```jsx
// âŒ WRONG - Object recreated every render
function DataFetcher() {
  const [data, setData] = useState(null);

  const options = { method: "GET", headers: { Accept: "application/json" } };

  useEffect(() => {
    fetch("/api/data", options)
      .then((res) => res.json())
      .then(setData);
  }, [options]); // options is different every render!

  return <div>{JSON.stringify(data)}</div>;
}
```

**ğŸ› Problem**: `options` object is recreated every render, causing infinite Effect runs.

**âœ… Fix**: Move objects outside component or memoize them.

```jsx
// âœ… Option 1: Move outside component
const API_OPTIONS = { method: "GET", headers: { Accept: "application/json" } };

function DataFetcher() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch("/api/data", API_OPTIONS)
      .then((res) => res.json())
      .then(setData);
  }, []); // No dependencies needed

  return <div>{JSON.stringify(data)}</div>;
}

// âœ… Option 2: Use useMemo
function DataFetcher() {
  const [data, setData] = useState(null);

  const options = useMemo(
    () => ({
      method: "GET",
      headers: { Accept: "application/json" },
    }),
    []
  );

  useEffect(() => {
    fetch("/api/data", options)
      .then((res) => res.json())
      .then(setData);
  }, [options]); // Now options is stable

  return <div>{JSON.stringify(data)}</div>;
}
```

### âŒ Mistake 3: Not Cleaning Up Side Effects

```jsx
// âŒ WRONG - No cleanup
function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
    // Missing cleanup! Timer keeps running after unmount
  }, []);

  return <div>Count: {count}</div>;
}
```

**ğŸ› Problem**: Timer continues running after component unmounts, causing memory leaks.

**âœ… Fix**: Always clean up timers, subscriptions, and event listeners.

```jsx
// âœ… CORRECT
function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);

    return () => clearInterval(timer); // Cleanup!
  }, []);

  return <div>Count: {count}</div>;
}
```

### âŒ Mistake 4: Race Conditions in Async Effects

```jsx
// âŒ WRONG - Race condition
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    async function fetchUser() {
      const response = await fetch(`/api/users/${userId}`);
      const userData = await response.json();
      setUser(userData); // This might set wrong user if userId changed!
    }

    fetchUser();
  }, [userId]);

  return <div>{user?.name}</div>;
}
```

**ğŸ› Problem**: If `userId` changes quickly, older requests might complete after newer ones, showing wrong data.

**âœ… Fix**: Use cleanup to cancel outdated requests.

```jsx
// âœ… CORRECT - Cancel outdated requests
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    const controller = new AbortController();

    async function fetchUser() {
      try {
        const response = await fetch(`/api/users/${userId}`, {
          signal: controller.signal,
        });
        const userData = await response.json();
        setUser(userData);
      } catch (error) {
        if (error.name !== "AbortError") {
          console.error("Failed to fetch user:", error);
        }
      }
    }

    fetchUser();

    return () => controller.abort(); // Cancel on cleanup
  }, [userId]);

  return <div>{user?.name}</div>;
}
```

### âŒ Mistake 5: Using Effects for Computed Values

```jsx
// âŒ WRONG - Using Effect for derived state
function ShoppingCart({ items }) {
  const [total, setTotal] = useState(0);

  useEffect(() => {
    const newTotal = items.reduce((sum, item) => sum + item.price, 0);
    setTotal(newTotal);
  }, [items]); // Unnecessary Effect!

  return <div>Total: ${total}</div>;
}
```

**ğŸ› Problem**: Unnecessary Effect and extra render for computed values.

**âœ… Fix**: Calculate during render or use useMemo.

```jsx
// âœ… CORRECT - Calculate during render
function ShoppingCart({ items }) {
  const total = items.reduce((sum, item) => sum + item.price, 0);

  return <div>Total: ${total}</div>;
}

// âœ… Or use useMemo for expensive calculations
function ShoppingCart({ items }) {
  const total = useMemo(() => {
    return items.reduce((sum, item) => sum + item.price, 0);
  }, [items]);

  return <div>Total: ${total}</div>;
}
```

---

## ğŸ” Debugging useEffect

### ğŸ› ï¸ Essential Debugging Techniques

#### 1. **Add Console Logs to Track Execution**

```jsx
function DebuggedComponent({ userId, filter }) {
  const [data, setData] = useState(null);

  useEffect(() => {
    console.log("ğŸ”„ Effect running with:", { userId, filter });

    const fetchData = async () => {
      console.log("ğŸ“¡ Starting fetch...");
      try {
        const response = await fetch(`/api/data/${userId}?filter=${filter}`);
        const result = await response.json();
        console.log("âœ… Fetch successful:", result);
        setData(result);
      } catch (error) {
        console.log("âŒ Fetch failed:", error);
      }
    };

    fetchData();

    return () => {
      console.log("ğŸ§¹ Effect cleanup for:", { userId, filter });
    };
  }, [userId, filter]);

  console.log("ğŸ¨ Component rendering with data:", data);

  return <div>{data ? `Data loaded: ${data.name}` : "Loading..."}</div>;
}
```

#### 2. **Use React DevTools Profiler**

```jsx
import { Profiler } from "react";

function App() {
  return (
    <Profiler
      id="UserProfile"
      onRender={(
        id,
        phase,
        actualDuration,
        baseDuration,
        startTime,
        commitTime
      ) => {
        console.log("Profiler:", {
          id,
          phase, // "mount" or "update"
          actualDuration, // Time spent rendering
          baseDuration, // Estimated time without memoization
          startTime,
          commitTime,
        });
      }}
    >
      <UserProfile userId="123" />
    </Profiler>
  );
}
```

#### 3. **Create a Debug Hook**

```jsx
import { useEffect, useRef } from "react";

function useWhyDidYouUpdate(name, props) {
  // Get a mutable ref object where we can store props for comparison next time this hook runs
  const previousProps = useRef();

  useEffect(() => {
    if (previousProps.current) {
      // Get all keys from previous and current props
      const allKeys = Object.keys({ ...previousProps.current, ...props });

      // Use this object to keep track of changed props
      const changedProps = {};

      // Iterate through keys
      allKeys.forEach((key) => {
        // If previous is different from current
        if (previousProps.current[key] !== props[key]) {
          // Add to changedProps
          changedProps[key] = {
            from: previousProps.current[key],
            to: props[key],
          };
        }
      });

      // If changedProps not empty then output to console
      if (Object.keys(changedProps).length) {
        console.log("[why-did-you-update]", name, changedProps);
      }
    }

    // Finally update previousProps with current props for next hook call
    previousProps.current = props;
  });
}

// Usage
function ExpensiveComponent({ userId, theme, settings }) {
  useWhyDidYouUpdate("ExpensiveComponent", { userId, theme, settings });

  useEffect(() => {
    // Some expensive effect
  }, [userId, theme, settings]);

  return <div>Expensive component</div>;
}
```

#### 4. **Effect Dependency Analyzer**

```jsx
function useEffectDebugger(effectHook, dependencies, dependencyNames = []) {
  const previousDeps = useRef();
  const changedDeps = useRef([]);

  useEffect(() => {
    const changes = [];

    if (previousDeps.current) {
      dependencies.forEach((dep, index) => {
        if (previousDeps.current[index] !== dep) {
          changes.push({
            name: dependencyNames[index] || `Dependency ${index}`,
            before: previousDeps.current[index],
            after: dep,
          });
        }
      });
    }

    if (changes.length > 0) {
      console.group("ğŸ”„ useEffect Dependencies Changed");
      changes.forEach(({ name, before, after }) => {
        console.log(`${name}:`, { before, after });
      });
      console.groupEnd();
    }

    changedDeps.current = changes;
    previousDeps.current = dependencies;
  });

  useEffect(effectHook, dependencies);

  return changedDeps.current;
}

// Usage
function MyComponent({ userId, settings }) {
  const [data, setData] = useState(null);

  const changes = useEffectDebugger(
    () => {
      fetchData(userId, settings).then(setData);
    },
    [userId, settings],
    ["userId", "settings"] // Names for debugging
  );

  return <div>{data?.name}</div>;
}
```

---

## ğŸ† Best Practices Summary

### âœ… Do's

1. **Keep Effects Pure**: Each Effect should have a single responsibility
2. **Use Proper Dependencies**: Include all reactive values in the dependency array
3. **Clean Up Side Effects**: Always clean up timers, subscriptions, and event listeners
4. **Handle Race Conditions**: Use AbortController for async operations
5. **Separate Concerns**: Use multiple Effects for different concerns
6. **Extract Custom Hooks**: Reuse Effect logic across components
7. **Use ESLint Plugin**: Let tooling catch dependency issues
8. **Prefer Functional Updates**: Reduce dependencies with `setState(prev => ...)`

### âŒ Don'ts

1. **Don't Use Effects for Computed Values**: Use regular variables or useMemo instead
2. **Don't Ignore Dependencies**: Missing dependencies cause stale closures
3. **Don't Create Objects in Render**: Move objects outside component or memoize them
4. **Don't Fetch in Render**: Use Effects for side effects, not render functions
5. **Don't Forget Cleanup**: Prevent memory leaks and unwanted side effects
6. **Don't Chain Effects**: If one Effect depends on another, combine them
7. **Don't Use Effects for Event Handlers**: Handle user interactions in event handlers

### ğŸ¯ Quick Decision Tree

```
Need to synchronize with external system?
  âœ… Use useEffect

Computing value from existing state/props?
  âŒ Don't use useEffect - calculate in render or use useMemo

Responding to user interaction?
  âŒ Don't use useEffect - use event handler

Need the same Effect logic in multiple components?
  âœ… Extract custom hook

Effect depends on frequently changing values?
  âœ… Consider if you can reduce dependencies
  âœ… Maybe extract event logic with useEffectEvent

Effect creates subscriptions/timers/listeners?
  âœ… Must include cleanup function

Async operation that might be outdated?
  âœ… Use AbortController or ignore flag
```

---

## ğŸ“ Advanced Effect Patterns

### ğŸ”„ Effect Composition Pattern

```jsx
// Composable effect hooks
function useDocumentTitle(title) {
  useEffect(() => {
    const previousTitle = document.title;
    document.title = title;

    return () => {
      document.title = previousTitle;
    };
  }, [title]);
}

function useBodyClass(className) {
  useEffect(() => {
    document.body.classList.add(className);

    return () => {
      document.body.classList.remove(className);
    };
  }, [className]);
}

function useKeyboardShortcut(key, callback) {
  useEffect(() => {
    const handleKeyPress = (event) => {
      if (event.key === key) {
        callback(event);
      }
    };

    document.addEventListener("keydown", handleKeyPress);

    return () => {
      document.removeEventListener("keydown", handleKeyPress);
    };
  }, [key, callback]);
}

// Compose multiple effects
function ProductPage({ product }) {
  useDocumentTitle(`${product.name} - My Store`);
  useBodyClass("product-page");
  useKeyboardShortcut("Escape", () => window.history.back());

  return <div>{product.name}</div>;
}
```

### ğŸ­ Effect Factory Pattern

```jsx
function createApiHook(baseUrl) {
  return function useApi(endpoint) {
    const [state, setState] = useState({
      data: null,
      loading: false,
      error: null,
    });

    useEffect(() => {
      const controller = new AbortController();

      async function fetchData() {
        setState((prev) => ({ ...prev, loading: true, error: null }));

        try {
          const response = await fetch(`${baseUrl}${endpoint}`, {
            signal: controller.signal,
          });

          if (!response.ok) throw new Error(`HTTP ${response.status}`);

          const data = await response.json();
          setState({ data, loading: false, error: null });
        } catch (error) {
          if (error.name !== "AbortError") {
            setState((prev) => ({
              ...prev,
              loading: false,
              error: error.message,
            }));
          }
        }
      }

      fetchData();

      return () => controller.abort();
    }, [endpoint]);

    return state;
  };
}

// Create specialized hooks
const useGitHubApi = createApiHook("https://api.github.com");
const useJsonPlaceholder = createApiHook(
  "https://jsonplaceholder.typicode.com"
);

// Usage
function GitHubProfile({ username }) {
  const { data: user, loading, error } = useGitHubApi(`/users/${username}`);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return <div>Hello, {user?.name}!</div>;
}
```

This completes the comprehensive guide to useEffect, covering everything from basic concepts to advanced patterns, common mistakes, debugging techniques, and best practices. The guide provides practical, real-world examples that developers can immediately apply to their React applications.
