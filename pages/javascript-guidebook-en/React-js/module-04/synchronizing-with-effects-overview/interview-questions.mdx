# React Effects (useEffect) Interview Questions & Answers 🎯

This guide covers interview questions and answers based on the topics in this module (React Effects: useEffect, advanced patterns, best practices). Use it to prepare for interviews or test your understanding of React effects.

> **💡 Pro Tip:** Use these questions to test yourself! Cover the answers and try to respond before checking. This active recall will help you better remember the concepts for your interview.

---

## 4.1 – Effect Fundamentals 🌱

<div style={{ background: 'rgba(0, 100, 200, 0.10)', padding: '15px', borderRadius: '5px', marginBottom: '20px', border: '1px solid rgba(0, 100, 200, 0.15)', color: 'inherit' }}>

**Q1: What is a side effect in React?**  
A: A side effect is any operation that affects something outside the component, such as data fetching, subscriptions, timers, or manually changing the DOM.

**Q2: What hook does React provide for handling side effects?**  
A: The `useEffect` hook.

**Q3: When does useEffect run?**  
A: After the component renders (after the DOM has been updated).

**Q4: What are some common use cases for useEffect?**  
A: Data fetching, event listeners, subscriptions, timers, updating the document title, and interacting with browser APIs.

**Q5: What is the basic syntax of useEffect?**  
A: `useEffect(() => { /* effect code */ }, [/* dependencies */])`

**Q6: What happens if you omit the dependency array in useEffect?**  
A: The effect runs after every render.

**Q7: How do you run an effect only once, on mount?**  
A: Pass an empty dependency array: `useEffect(() => { ... }, [])`

**Q8: How do you run an effect when specific values change?**  
A: List those values in the dependency array: `useEffect(() => { ... }, [value1, value2])`

**Q9: What is the purpose of the cleanup function in useEffect?**  
A: To clean up resources (like subscriptions, timers, or event listeners) when the component unmounts or before the effect re-runs.

Example:
```jsx
useEffect(() => {
  const handler = () => window.alert('resize');
  window.addEventListener('resize', handler);
  return () => window.removeEventListener('resize', handler);
}, []);
```

**Q10: How do you provide a cleanup function in useEffect?**  
A: Return a function from the effect: `useEffect(() => { ...; return () => { /* cleanup */ } }, [...])`

</div>

> **🔍 Interview Insight:** Understanding the effect lifecycle and cleanup is crucial for real-world React apps.

---

## 4.2 – Effect Lifecycle & Dependencies 🔄

<div style={{ background: 'rgba(230, 150, 70, 0.10)', padding: '15px', borderRadius: '5px', marginBottom: '20px', border: '1px solid rgba(230, 150, 70, 0.15)', color: 'inherit' }}>

**Q11: What are the three main phases of the effect lifecycle?**  
A: Mount (effect runs after first render), Update (effect runs after dependencies change), Unmount (cleanup runs when component is removed).

**Q12: What is the dependency array in useEffect?**  
A: An array that tells React when to re-run the effect (when any listed value changes).

**Q13: What happens if you list an object or array as a dependency?**  
A: The effect may run more often than expected, because objects/arrays are compared by reference, not value.

**Q14: How can you avoid unnecessary effect runs with objects/arrays?**  
A: Use `useMemo` or `useCallback` to memoize them, or use primitive dependencies when possible.

Example:
```jsx
const memoizedSettings = useMemo(() => ({ theme }), [theme]);
useEffect(() => {
  // Only runs when theme changes
}, [memoizedSettings]);
```

**Q15: What is the 'reference equality trap' in effect dependencies?**  
A: React compares dependencies using reference equality, so new object/array/function instances will always trigger the effect.

**Q16: How do you handle functions as dependencies?**  
A: Use `useCallback` in the parent, or use a ref to store the function.

**Q17: What is a common mistake with missing dependencies?**  
A: Not including all values used inside the effect, which can cause bugs due to stale closures.

**Q18: How can you debug dependency issues?**  
A: Use React DevTools, add console logs, and follow the exhaustive-deps ESLint rule.

**Q19: What is the effect cleanup order when dependencies change?**  
A: Cleanup runs before the new effect runs.

**Q20: What happens if you return nothing from useEffect?**  
A: No cleanup is performed.

</div>

---

## 4.3 – Real-World Effect Patterns 🌐

<div style={{ background: 'rgba(50, 180, 50, 0.10)', padding: '15px', borderRadius: '5px', marginBottom: '20px', border: '1px solid rgba(50, 180, 50, 0.15)', color: 'inherit' }}>

**Q21: How do you fetch data with useEffect?**  
A: Start the fetch inside the effect, update state with the result, and clean up with AbortController if needed.

Example:
```jsx
useEffect(() => {
  const controller = new AbortController();
  async function fetchData() {
    const res = await fetch('/api/data', { signal: controller.signal });
    const data = await res.json();
    setData(data);
  }
  fetchData();
  return () => controller.abort();
}, []);
```

**Q22: Why should you use AbortController in data-fetching effects?**  
A: To cancel ongoing requests if the component unmounts or dependencies change, preventing memory leaks and unwanted state updates.

**Q23: How do you set up and clean up event listeners in useEffect?**  
A: Add the listener in the effect, and remove it in the cleanup function.

**Q24: How do you handle timers or intervals in useEffect?**  
A: Set up the timer/interval in the effect, and clear it in the cleanup function.

Example:
```jsx
useEffect(() => {
  const timer = setInterval(() => setCount(c => c + 1), 1000);
  return () => clearInterval(timer);
}, []);
```

**Q25: What is a common anti-pattern when using effects for calculations?**  
A: Using effects for pure calculations that could be done during render or with `useMemo`.

**Q26: When should you avoid using useEffect?**  
A: When you can derive the value directly from props/state or with `useMemo`.

**Q27: How do you update the document title with useEffect?**  
A: Call `document.title = ...` inside the effect, and optionally reset it in the cleanup.

**Q28: How do you persist state to localStorage with useEffect?**  
A: Use an effect that runs when the state changes, and call `localStorage.setItem` inside it.

Example:
```jsx
useEffect(() => {
  localStorage.setItem('count', count);
}, [count]);
```

**Q29: How do you read from localStorage on mount?**  
A: Use an effect with an empty dependency array to read and set state from localStorage.

**Q30: How do you handle subscriptions (e.g., WebSocket, external APIs) in useEffect?**  
A: Set up the subscription in the effect, and clean it up (unsubscribe/disconnect) in the cleanup function.

</div>

---

## 4.4 – Advanced Effect Patterns & Best Practices 🛠️

<div style={{ background: 'rgba(100, 100, 200, 0.10)', padding: '15px', borderRadius: '5px', marginBottom: '20px', border: '1px solid rgba(100, 100, 200, 0.15)', color: 'inherit' }}>

**Q31: What is debouncing in effects, and how do you implement it?**  
A: Debouncing delays effect execution until a value stops changing for a set time, usually implemented with `setTimeout` and `clearTimeout` in the effect.

**Q32: What is throttling in effects?**  
A: Throttling limits how often an effect runs, typically by tracking the last run time and only running after a certain interval.

**Q33: How do you handle polling with useEffect?**  
A: Use `setInterval` in the effect to repeatedly fetch data, and clear the interval in the cleanup.

**Q34: What is a race condition in async effects, and how do you prevent it?**  
A: A race condition occurs when multiple async operations overlap; prevent it by tracking the current request (e.g., with a flag or AbortController) and only updating state for the latest one.

**Q35: How do you split complex effects into smaller ones?**  
A: Use multiple useEffect calls, each focused on a single concern.

**Q36: What is the benefit of keeping effects focused?**  
A: Easier to debug, maintain, and avoid unnecessary re-runs.

**Q37: How do you minimize effect dependencies?**  
A: Move non-reactive values inside the effect, use refs for stable values, and extract constants/functions outside the component.

**Q38: How do you use refs to avoid unnecessary effect runs?**  
A: Store values in a ref if you don't want changes to trigger the effect.

**Q39: What is the difference between event handlers and effects?**  
A: Event handlers respond to user actions; effects respond to state/prop/context changes.

**Q40: How do you decide if logic belongs in an event handler or an effect?**  
A: If it's triggered by user action, use an event handler; if it's triggered by data changes, use an effect.

</div>

---

## 4.5 – Custom Hooks & Effect Reuse 🪝

<div style={{ background: 'rgba(50, 180, 150, 0.10)', padding: '15px', borderRadius: '5px', marginBottom: '20px', border: '1px solid rgba(50, 180, 150, 0.15)', color: 'inherit' }}>

**Q41: What is a custom hook in React?**  
A: A function that starts with `use` and encapsulates reusable stateful logic, including effects.

**Q42: Why use custom hooks for effects?**  
A: To share effect logic across components, keep code DRY, and improve testability.

**Q43: How do you write a custom hook for data fetching?**  
A: Create a function (e.g., `useFetch`) that uses `useEffect` and `useState` internally, and returns the data, loading, and error states.

Example:
```jsx
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  useEffect(() => {
    let ignore = false;
    fetch(url)
      .then(res => res.json())
      .then(json => { if (!ignore) setData(json); })
      .finally(() => { if (!ignore) setLoading(false); });
    return () => { ignore = true; };
  }, [url]);
  return { data, loading };
}
```

**Q44: How do you handle cleanup in custom hooks?**  
A: Return a cleanup function from the effect inside the hook, just like in a component.

**Q45: What are some best practices for custom hooks with effects?**  
A: Keep them focused, document dependencies, handle cleanup, and return stable APIs.

**Q46: Can custom hooks call other hooks?**  
A: Yes, custom hooks can use other hooks, including useEffect, useState, useRef, etc.

**Q47: What is a common mistake when writing custom hooks with effects?**  
A: Forgetting to include all dependencies or not handling cleanup properly.

**Q48: How do you test custom hooks with effects?**  
A: Use testing libraries like `@testing-library/react-hooks` to render the hook and assert its behavior.

**Q49: How do you compose multiple hooks for advanced logic?**  
A: Call multiple hooks inside a custom hook and combine their results/logic as needed.

**Q50: What is the benefit of returning objects (not arrays) from custom hooks?**  
A: Objects provide named properties, making the API more flexible and readable.

</div>

---

## 4.6 – Common Mistakes, Debugging & Scenarios 🐛

<div style={{ background: 'rgba(220, 50, 50, 0.10)', padding: '15px', borderRadius: '5px', marginBottom: '20px', border: '1px solid rgba(220, 50, 50, 0.15)', color: 'inherit' }}>

**Q51: What happens if you forget to clean up an effect?**  
A: You may get memory leaks, duplicate subscriptions, or unwanted side effects.

**Q52: What causes infinite loops in useEffect?**  
A: Updating state inside an effect that depends on that state, or missing dependencies that cause repeated re-runs.

**Q53: How do you debug effect issues?**  
A: Use console logs, React DevTools, check dependency arrays, and verify cleanup functions.

**Q54: What is the exhaustive-deps ESLint rule?**  
A: A rule that warns if you forget to include dependencies in your effect's dependency array.

**Q55: How do you handle errors in async effects?**  
A: Use try/catch blocks and set error state as needed.

**Q56: What is a scenario where you should use multiple effects instead of one?**  
A: When you have unrelated logic (e.g., one effect for data fetching, another for event listeners).

**Q57: How do you test if your effect cleanup works?**  
A: Unmount the component and check if resources (timers, listeners) are released.

**Q58: What is a scenario-based question for effect usage?**  
A: See below for a practical scenario and sample answer.

</div>

---

## Practice Interview Exercise 🏋️‍♂️

<div style={{ background: 'rgba(20, 120, 220, 0.10)', padding: '20px', borderRadius: '5px', marginBottom: '20px', border: '1px solid rgba(20, 120, 220, 0.15)', color: 'inherit' }}>

### Scenario-Based Question:

You are building a chat application. When the user enters a chat room, you need to:
- Connect to a WebSocket
- Listen for new messages
- Update the UI in real time
- Clean up the connection when the user leaves the room

**Question:** How would you implement this with useEffect? What are the key points to ensure correct behavior and avoid bugs?

Take a moment to formulate your answer before checking the suggested response.

<details>
<summary>**Click to see a sample answer**</summary>

**Sample Approach:**

```jsx
useEffect(() => {
  const connection = createConnection(roomId);
  connection.connect();
  connection.on('message', handleMessage);
  return () => {
    connection.disconnect();
  };
}, [roomId]);
```

- Set up the connection in the effect
- Clean up by disconnecting in the cleanup function
- Include all dependencies (e.g., roomId, handleMessage)
- Avoid memory leaks and duplicate listeners

</details>
</div>

---

## 4.7 – Advanced Scenarios, Performance, and Accessibility ⚡️

<div style={{ background: 'rgba(100, 180, 255, 0.10)', padding: '15px', borderRadius: '5px', marginBottom: '20px', border: '1px solid rgba(100, 180, 255, 0.15)', color: 'inherit' }}>

**Q59: How can you optimize performance when using effects in large React apps?**  
A: Minimize dependencies, split effects by concern, use memoization (`useMemo`, `useCallback`), avoid unnecessary state updates, and clean up resources promptly.

**Q60: What are some accessibility considerations when using effects?**  
A: Ensure focus management after effects, announce state changes for screen readers, and avoid disrupting keyboard navigation or screen reader context.

**Q61: How do you handle effect logic that depends on the previous value of a prop or state?**  
A: Use a ref to store the previous value, or use the functional form of state setters inside the effect.

Example:
```jsx
const prevValue = useRef();
useEffect(() => {
  if (prevValue.current !== undefined) {
    // Compare prevValue.current and value
  }
  prevValue.current = value;
}, [value]);
```

**Q62: What is the risk of updating state in an effect without proper dependencies?**  
A: It can cause infinite loops or stale state bugs if dependencies are missing or incorrect.

**Q63: How do you migrate class component lifecycle methods (componentDidMount, componentDidUpdate, componentWillUnmount) to useEffect?**  
A: Use `useEffect(() => { ... }, [])` for `componentDidMount`, add dependencies for `componentDidUpdate`, and return a cleanup function for `componentWillUnmount`.

Example:
```jsx
// componentDidMount
useEffect(() => {
  // run once on mount
}, []);

// componentDidUpdate (for prop change)
useEffect(() => {
  // run when prop changes
}, [prop]);

// componentWillUnmount
useEffect(() => {
  // setup
  return () => {
    // cleanup
  };
}, []);
```

**Q64: How can you ensure your effects are secure when fetching data?**  
A: Validate and sanitize API responses, handle errors gracefully, and avoid exposing sensitive data in logs or state.

**Q65: What is a common pitfall when using async functions directly in useEffect?**  
A: You cannot make the effect callback itself async; instead, define and call an async function inside the effect.

Example:
```jsx
useEffect(() => {
  async function fetchData() {
    // await ...
  }
  fetchData();
}, []);
```

**Q66: How do you handle effect logic that should only run in production, not development?**  
A: Use environment checks (e.g., `if (process.env.NODE_ENV === 'production')`) inside the effect.

**Q67: What is a scenario where you might want to delay effect execution until after a user interaction?**  
A: For analytics tracking, expensive calculations, or data fetching that should only occur after a button click or form submission.

**Q68: How do you prevent memory leaks in effects that use subscriptions or timers?**  
A: Always return a cleanup function that unsubscribes, disconnects, or clears timers/intervals.

Example:
```jsx
useEffect(() => {
  const timer = setInterval(() => { /* ... */ }, 1000);
  return () => clearInterval(timer);
}, []);
```

</div>

---

**Tip:** Review these questions and answers, and try to explain the concepts in your own words for the best interview preparation!

> **🚀 Final Advice:** In interviews, show not just your knowledge of effects, but also your understanding of why and how to use them effectively in real-world React apps.
