Although state variables look like normal JavaScript variables, they don't work like normal JavaScript variables at all. Let's learn about this in detail.

### Rendering takes a snapshot in time:

This means that React takes a `snapshot` of each render and remembers it. Whenever a state value changes, React re-renders the component and the value is updated in the next render. This means that unlike normal variables where we can change a value and access it in the next line, we can't do that in React because React doesn't change values in place. The value changes in the next render.

Let's understand with an example:

```jsx filename="App.jsx" showLineNumbers
import { useState } from "react";
export default function App() {
    const [number, setNumber] = useState(1);

    function handleClick() {
        setNumbers(number + 5);
        console.log(number);
    }

    return <button onClick={handleClick}>Incriment the number</button>;
}
```

What output should we expect in the console for the code above? Normally, one might think that the output should be `6`. But no, the output here will be `1`. This is because React doesn't directly change the value when its state changes, so that value can't be accessed in the subsequent lines.

The entire code of the handler function where the `setter function` is called executes completely before a re-render is triggered, and the updated value is available in the next render.

Let's look at another example:

```jsx filename="App.jsx" showLineNumbers
import { useState } from "react";

export default function Counter() {
    const [number, setNumber] = useState(0);

    return (
        <>
            <h1>{number}</h1>
            <button
                onClick={() => {
                    setNumber(number + 1);
                    setNumber(number + 1);
                    setNumber(number + 1);
                }}>
                +3
            </button>
        </>
    );
}
```

Here, the `setter function` is called three times in a button and the state value is updated three times. If we run this code and click the button, what should the output be - `3`?

But no, the output will be `1`.

Since the state only changes in the next render, the value of the state in the first render was `0`. So even though the `setter function` is called three times in the first render, it will get the initial value of the state, which is `0`, all three times. And that's why the output of `number` will be `1`.

```jsx filename="App.jsx" showLineNumbers
<button
    onClick={() => {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
    }}>
    +3
</button>
```

What's happening here is that in the first render, when `setNumber(number + 1)` is first called, it's actually doing `0 + 1 = 1`, which will appear in the output in the next render.

But before going to the next render, `setNumber(number + 1)` is called two more times.

That means it's still doing `0 + 1 = 1`.

So when `setNumber(number + 1)` is called for the last time, it's still doing `0 + 1 = 1`, and the state triggers the next render with `1` in its memory, and `1` is printed in the output.

```jsx filename="App.jsx" showLineNumbers
<button
    onClick={() => {
        setNumber(0 + 1);
        setNumber(0 + 1);
        setNumber(0 + 1);
    }}>
    +3
</button>
```

Now if the code is like this:

```jsx filename="App.jsx" showLineNumbers
export default function Counter() {
    const [number, setNumber] = useState(0);

    return (
        <>
            <h1>{number}</h1>
            <button
                onClick={() => {
                    setNumber(number + 5);
                    setTimeout(() => {
                        alert(number);
                    }, 3000);
                }}>
                +5
            </button>
        </>
    );
}
```

Here, the state of the number is changed in the button and a `setTimeout()` is called for 3 seconds. And the value of the number is taken in an alert.

Here, too, one might think that the value of the number in the alert will be `5`, because by the time the 3-second timer ends, the state will have re-rendered and we will get the updated value in the alert.

But no, here too we have to think of it as a `snapshot`. Here, even though the `timeout` happens after three seconds, when the timeout started, it took the value of `number` as `0`, so no matter how long the timer takes, it will get the same thing in the first render, which is its initial value.

**In other words, the value never changes directly in a React render. Rather, when the state changes, a re-render is triggered, and the updated value is available in the next render.**

