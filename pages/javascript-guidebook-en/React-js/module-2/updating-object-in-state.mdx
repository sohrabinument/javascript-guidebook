import { Callout, Steps } from "nextra/components";

**React can take any type of JavaScript value as its state. But whenever we use a JavaScript object as a React state, we can never directly change or mutate it. In this case, we have to completely replace the previous object with a new object, or make a copy of the previous object and replace the state's object with that copy object. In other words, however we do it, we always have to replace the previous value with a new value when updating the state.**

### (What is a Mutation) What is Mutation?

Mutation means to change. In JavaScript terms, directly changing the value of a variable is called mutation. React discourages directly changing the value of a state. In React, any value can be stored as state, such as `string`, `number`, `Boolean`, `Array`, `Object`.

`string`, `number`, `Boolean` are JavaScript primitive values that are `read-only` or can never be changed.

On the other hand, `Array`, `Object` are reference values. Although they can technically be changed, React forbids directly changing reference values in state values. React suggests thinking of these values as `read-only` when updating state.

To learn more about JavaScript's primitive and reference values, [click here](https://reactive-accelarator.vercel.app/javascript-guidebook/javascript-refresher#primitive-and-reference-types-value)

Let's understand in detail with an example:

```jsx
const [x, setX] = useState(0);
```

Here, the value of the state variable `x` has been set to `0`, which is a primitive value.

```jsx
setX(5);
```

Here, the value of the state variable `x` has been set to `5` using `setX`. Here, the value of `x`, which is `0`, hasn't been changed, because it's a primitive value that can never be changed or is `read-only`. Rather, the previous value has been replaced with `5`, which is a new value.

But when our state value will be an object like this,

```jsx
const [position, setPosition] = useState({ x: 0, y: 0 });
```

Although it's technically possible to change it like `position.x = 5;`, doing so mutates the main object. This is never recommended by React. **You must always replace the previous value with a completely new value or a new object when changing the state.**

So how do we do it? Let's find out.

### (Treat state as read-only) React's state should be thought of as `read-only`.

```jsx filename="App.js" showLineNumbers
import { useState } from "react";

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
  });
  return (
    <div
      onPointerMove={(e) => {
        position.x = e.clientX;
        position.y = e.clientY;
      }}
      style={{
        position: "relative",
        width: "100vw",
        height: "100vh",
      }}
    >
      <div
        style={{
          position: "absolute",
          backgroundColor: "red",
          borderRadius: "50%",
          transform: `translate(${position.x}px, ${position.y}px)`,
          left: -10,
          top: -10,
          width: 20,
          height: 20,
        }}
      />
    </div>
  );
}
```

In the code above, a pointer has been created that should follow and move with the mouse as it moves. But if you run the code, you'll see it's not working.

It's not working because there's a mistake in this part of the code:

```jsx
    onPointerMove={e => {
      position.x = e.clientX;
      position.y = e.clientY;
    }}
```

Here, in the `onPointerMove` `event listener`, the value of the state variable `position` is being directly changed after it has been rendered on the screen once, which is why it's not working. Because the change isn't being made in a `setter function`, React doesn't even know that the state value has changed and that it needs to re-render.

In this case, to change it, it needs to be changed inside the `setter function` so that the re-render is triggered as soon as the value changes.

```jsx
onPointerMove((e) => {
  setPosition({
    x: e.clientX,
    y: e.clientY,
  });
});
```

Notice that here, no value of the previous `position` object has been changed; a completely new object has been created and the previous object has been replaced.

<Callout type="info" emoji="ðŸ“”">
**Local mutations are fine.**

You can't code like this, which directly changes the current state object `position`:

```jsx
position.x = e.clientX;
position.y = e.clientY;
```

But if you code like this, where you create a completely new object and replace the previous state value's object, then it's perfectly fine:

```jsx
    setPosition((e)=>{
        x: e.clientX,
        y: e.clientY
    })
```

You can also create a local object variable and use it to change:

```jsx
const nextPosition = {};
nextPosition.x = e.clientX;
nextPosition.y = e.clientY;

setPosition(nextPosition);
```

Doing it this way is also fine because the state variable's `position` object isn't being modified; a new object is being created and replacing the previous value of the state.

Mutation is only a problem when you're directly changing an existing object of a state. Otherwise, you can change local variables; there's no problem with that.

</Callout>

### Copying objects with the spread syntax

As we saw in the previous example, when we change a state's object value, we need to give a new object to the state. That means we need to create a fresh object each time.

But if our object is very large, then every time we want to update the state, if we have to write such a large object from scratch, it becomes a problem and there's a greater chance of errors.

In this case, we can make a copy of the previous object and only change the values we want to change, and the trouble is over.

JavaScript's `... spread` operator helps us do this. Using the `... spread` operator, we can create a `Shallow` copy of the previous object. However, remember that the `... spread` operator only copies one level in the case of nested objects. If we want to copy deeply, we need to use the `... spread` operator multiple times.

To learn more about `Shallow Copy` and `Deep Copy`, [click on this link](https://reactive-accelarator.vercel.app/javascript-guidebook/javascript-refresher#shallow-copy-vs-deep-copy)

Let's say we need to change the value of the `firstName` property of this object state variable.

```jsx
const [person, setPerson] = useState({
  firstName: "Barbara",
  lastName: "Hepworth",
  email: "bhepworth@sculpture.com",
});
```

Then we can do it like this:

```jsx
setPerson({
  firstName: "Shahadat Hussain Ripon",
  lastName: "Hepworth",
  email: "bhepworth@sculpture.com",
});
```

This will work very well. But it requires us to write the same thing over and over again.

But if we use the `...spread` operator, we can write it more easily like this:

```jsx
setPerson({
  ...person, // Here all the data from our previous object has been copied and set as properties of the new object.
  firstName: "Shahadat Hussain Ripon", // Here we are changing the property value
});
```

### (Updating a nested object) How to update a nested object in state?

Let's say our state structure is like this:

```jsx
const [person, setPerson] = useState({
  name: "Niki de Saint Phalle",
  artwork: {
    title: "Blue Nana",
    city: "Hamburg",
    image: "https://i.imgur.com/Sd1AgUOm.jpg",
  },
});
```

And we want to update the value of `person.artwork.city`.

Then we can do it like this:

```jsx
const changedArtwork = { ...person.artwork, city: "Narayangonj" };
const changedPerson = { ...person, artwork: changedArtwork };
setPerson(changedPerson);
```

Or if we want to make the change within a single function call, we can do it like this:

```jsx
setPerson({
  ...person, // All fields of the previous object have been copied
  artwork: {
    ...person.artwork, // All data of the artwork field of the previous object has been copied
    city: "Narayangonj", // The property value has been changed
  },
});
```

<Callout
    type='info'
    emoji='ðŸ“”'>
    **The truth is that objects are never nested.**

```jsx
let obj = {
  name: "Niki de Saint Phalle",
  artwork: {
    title: "Blue Nana",
    city: "Hamburg",
    image: "https://i.imgur.com/Sd1AgUOm.jpg",
  },
};
```

Looking at this object, it seems nested, but the truth is that when our code executes, there's no such thing as a nested object. It then actually becomes two objects.

```jsx
let obj1 = {
  title: "Blue Nana",
  city: "Hamburg",
  image: "https://i.imgur.com/Sd1AgUOm.jpg",
};

let obj2 = {
  name: "Niki de Saint Phalle",
  artwork: obj1,
};
```

Then perhaps another object can be created with a reference to one object, like this:

```jsx
let obj1 = {
  title: "Blue Nana",
  city: "Hamburg",
  image: "https://i.imgur.com/Sd1AgUOm.jpg",
};

let obj2 = {
  name: "Niki de Saint Phalle",
  artwork: obj1,
};

let obj3 = {
  name: "Something",
  artwork: obj1,
};
```

In such a case, if you make any changes to `obj1`, then because it's a reference value, that change will also affect `obj3`.

</Callout>

### (Write concise update logic with Immer) Changing nested objects worry-free with Immer.

If we want to change nested objects in state very easily, without any worry, React recommends a third-party package called `Immer`.

We can also use `Immer` to very easily change our complex nested object states if we want.

`Immer` gives us a special object called `draft`, which creates a `Proxy` object of the previous complex object, and finds out what changes we make, and immutably updates the previous object. In this case, we don't have to worry about the issue of `Mutation` because `Immer` manages it itself.

### How to use `Immer`

<Steps>
### install `Immer` package

```bash
 npm install use-immer
```

### import useImmer

```jsx
import { useImmer } from "use-immer";
```

### change `useState` to `useImmer`

`useState` will be changed to `useImmer`

```jsx
import { useImmer } from "use-immer";

const [person, setPerson] = useState({}); // This line needs to be changed
const [person, updatePerson] = useImmer({}); // Define state like this
```

### Update state like below

```jsx
import { useImmer } from "use-immer";

const [person, updatePerson] = useImmer({
  firstName: "test",
  lastName: "user",
  contact: {
    email: "testuser@gmail.com",
    phone: "+88016666182731",
    github: "testuser",
  },
});

updateImmer((draft) => {
  // state updater immer function
  draft.firstName = "Sohrab Hossain";
  draft.lastName = "Sohrab";
  draft.contact.email = "md.soharubhossen@gmail.com";
});
```

</Steps>

Doing it this way might seem like we're breaking React's rules, but no, actually when we're mutating the `draft` here, under the hood, `Immer` itself is immutably updating our state.
