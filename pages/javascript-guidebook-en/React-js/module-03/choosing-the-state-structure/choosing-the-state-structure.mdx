# üèóÔ∏è Choosing the State Structure in React

## Introduction

Structuring your state well can make your React components easier to build, debug, and maintain! Let's learn how to choose the best state structure for your app. üöÄ

---

## üå± Principles for Structuring State

When you write a component that holds state, you have to decide:
- How many state variables do you need?
- What should their data shape be?

Here are some golden rules to help you:

1. **üß© Group related state.**
2. **üö´ Avoid contradictions in state.**
3. **üîÑ Avoid redundant state.**
4. **üì¶ Avoid duplication in state.**
5. **üå≥ Avoid deeply nested state.**

Let's look at each principle in detail, with practical examples!

---

## üß© 1. Group Related State

If you always update two or more state variables together, consider merging them into a single state variable. This keeps your data in sync and your code clean!

**Real-world analogy:**
> Imagine you're tracking a player's position in a game. You always update both x and y when the player moves. It's easier to keep them together!

**Bad Example (Separate State):**
```js
const [x, setX] = useState(0);
const [y, setY] = useState(0);

function movePlayer(newX, newY) {
  setX(newX);
  setY(newY);
}
```
If you forget to update one, your state is out of sync! üò¨

**Good Example (Grouped State):**
```js
const [position, setPosition] = useState({ x: 0, y: 0 });

function movePlayer(newX, newY) {
  setPosition({ x: newX, y: newY });
}
```
Now, you always update both together. Much safer! üõ°Ô∏è

---

## üö´ 2. Avoid Contradictions in State

Don't let your state variables "disagree" with each other! Contradictory state can lead to bugs that are hard to find.

**Real-world analogy:**
> Imagine a traffic light that is both green and red at the same time. That's a contradiction! ‚ùå

**Bad Example:**
```js
const [isSending, setIsSending] = useState(false);
const [isSent, setIsSent] = useState(false);

// Oops! Both could be true at once if not careful
```

**Better Example:**
```js
const [status, setStatus] = useState('idle'); // 'idle', 'sending', or 'sent'

// Now, only one status can be true at a time!
```

---

## üîÑ 3. Avoid Redundant State

If you can calculate something from props or other state, don't store it separately! Redundant state can get out of sync and cause bugs.

**Real-world analogy:**
> If you already know someone's birth year and the current year, you don't need to store their age‚Äîyou can calculate it! üéÇ

**Bad Example:**
```js
const [age, setAge] = useState(currentYear - birthYear); // Redundant!
```

**Good Example:**
```js
const age = currentYear - birthYear; // Calculate when needed
```

**Another Example:**
```js
const [firstName, setFirstName] = useState('Ada');
const [lastName, setLastName] = useState('Lovelace');
// ‚ùå Don't store fullName in state
const fullName = firstName + ' ' + lastName; // ‚úÖ Just compute it
```

---

## üì¶ 4. Avoid Duplication in State

Don't store the same data in multiple places. Duplicated state is hard to keep in sync and can lead to confusion. ü§π‚Äç‚ôÇÔ∏è

**Real-world analogy:**
> Imagine keeping two separate lists of your friends. If you add a friend to one list but forget the other, they're out of sync!

**Bad Example:**
```js
const [items, setItems] = useState(['apple', 'banana']);
const [itemCount, setItemCount] = useState(2); // Duplicated!

function addItem(item) {
  setItems([...items, item]);
  setItemCount(itemCount + 1); // Easy to forget!
}
```

**Good Example:**
```js
const [items, setItems] = useState(['apple', 'banana']);
const itemCount = items.length; // Always correct!
```

---

## üå≥ 5. Avoid Deeply Nested State

Deeply nested state (like objects inside objects inside arrays) is hard to update and maintain. Try to keep your state as flat as possible! üèûÔ∏è

**Real-world analogy:**
> Imagine a set of Russian dolls. If you want to change the smallest one, you have to open all the others first! ü™Ü

**Bad Example (Deep Nesting):**
```js
const [state, setState] = useState({
  user: {
    profile: {
      name: '',
      age: 0
    }
  }
});

// Updating name is awkward:
setState(prev => ({
  ...prev,
  user: {
    ...prev.user,
    profile: {
      ...prev.user.profile,
      name: 'Grace'
    }
  }
}));
```

**Good Example (Flat State):**
```js
const [profile, setProfile] = useState({ name: '', age: 0 });
// Much easier to update!
setProfile(prev => ({ ...prev, name: 'Grace' }));
```

---

## üß† Recap

- üß© Group related state together if they always change together.
- üö¶ Avoid contradictory state by using a single status variable.
- üîÑ Don't store what you can calculate.
- üì¶ Don't duplicate data in state.
- üå≥ Keep your state as flat as possible.
- üèÜ Well-structured state = fewer bugs and easier code!

---

## üìö Learn More

For more details and examples, check out the [official React documentation](https://react.dev/learn/choosing-the-state-structure#group-related-state).

---

## üßÆ Derived State

**Derived state** is any value you can calculate from props or other state, rather than storing it separately in its own state variable.

**Why avoid storing derived state?**
- It can get out of sync with the source data, leading to bugs.
- It's simpler and less error-prone to calculate it when needed.

**Example:**
```js
const [firstName, setFirstName] = useState('Ada');
const [lastName, setLastName] = useState('Lovelace');
// ‚ùå Don't do this:
// const [fullName, setFullName] = useState(firstName + ' ' + lastName);
// ‚úÖ Do this:
const fullName = firstName + ' ' + lastName;
```
Here, `fullName` is derived from `firstName` and `lastName`.

**Best Practice:**
> Only store state that cannot be computed from other state or props. If you can derive it, just calculate it in your render logic! üß†

---

## üîÑ Props Mirroring

**Props mirroring** (sometimes called "mirrored state") is when a child component copies a prop value into its own state variable.

**Why is this usually discouraged?**
- The child's state can get out of sync with the parent's prop.
- It creates confusion about the "source of truth" for the data.

**When is props mirroring okay?**
- If you only need the prop value once (e.g., as an initial value), and after that the child manages it independently.
- If you don't need to keep the child's state in sync with the parent's prop.

**Example:**
```js
function Child({ initialValue }) {
  // Only use the prop to set the initial state
  const [value, setValue] = useState(initialValue);
  // After this, 'value' is managed by the child
  // and does not update if initialValue changes
}
```

**Bad Example (Mirroring for sync):**
```js
function Child({ value }) {
  // ‚ùå This is bad! It will not update if parent changes 'value'
  const [localValue, setLocalValue] = useState(value);
}
```

**Best Practice:**
> If you want the child to always reflect the parent's prop, don't copy it to state‚Äîjust use the prop directly! If you want the child to manage its own value after initialization, mirroring is okay.

**Summary Table:**

| Situation                                              | Should you mirror props? |
|--------------------------------------------------------|-------------------------|
| Need to keep in sync with parent                       | ‚ùå No                   |
| Only need initial value, then manage independently     | ‚úÖ Yes                  |
| Want to control child from parent (controlled input)   | ‚ùå No                   |

---
