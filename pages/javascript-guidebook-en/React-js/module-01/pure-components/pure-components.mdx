# Pure Components in React

## What are Pure Components? üß™

Think of a pure component as a reliable calculator: when you input `2+2`, it always returns `4` - never a different answer, and it never changes anything else while calculating.

In React, a **pure component**:

- Always returns the same UI output when given the same inputs (props and state)
- Doesn't change anything outside itself (no side effects)

It's like a good kitchen recipe - if you follow it exactly with the same ingredients, you'll get the same dish every time.

## Why Should You Care? ü§î

Pure components make your React apps better because:

- ‚úÖ **Predictable behavior**: Your UI stays consistent and reliable
- ‚úÖ **Better performance**: React can skip unnecessary re-renders
- ‚úÖ **Easier testing**: Components behave consistently in tests
- ‚úÖ **Fewer bugs**: Side effects are the source of many bugs
- ‚úÖ **Future-ready**: Modern React features like concurrent rendering rely on pure components

## Keeping Components Pure: The Golden Rules üìù

### Rule 1: Don't Change Pre-existing Data

```jsx
// ‚ùå BAD: Changing external variables
let counter = 0;
function Counter() {
  // This is changing data outside the component!
  counter++;
  return <div>Count: {counter}</div>;
}

// ‚úÖ GOOD: Using React's state
function Counter() {
  // React state is the right way to handle changing data
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1); // Proper way to update
  }

  return (
    <div>
      Count: {count} <button onClick={handleClick}>+1</button>
    </div>
  );
}
```

### Rule 2: Don't Modify Props Directly

```jsx
// ‚ùå BAD: Modifying props (this causes bugs!)
function ProfileCard({ user }) {
  // Never change the props you receive!
  user.lastSeen = Date.now();

  return <div>{user.name} was last seen just now</div>;
}

// ‚úÖ GOOD: Create new objects instead
function ProfileCard({ user }) {
  // Create a new object with the updates
  const updatedUser = {
    ...user,
    lastSeen: Date.now(),
  };

  return <div>{updatedUser.name} was last seen just now</div>;
}
```

### Rule 3: Same Inputs ‚Üí Same Outputs

```jsx
// ‚ùå BAD: Output depends on things other than props/state
function Greeting({ name }) {
  // This depends on the current time, not just props!
  const greeting = new Date().getHours() < 12 ? "Good morning" : "Good day";

  return (
    <h1>
      {greeting}, {name}!
    </h1>
  );
}

// ‚úÖ GOOD: Receiving all inputs as props
function Greeting({ name, timeOfDay }) {
  // Now it's predictable - same inputs always give same output
  const greeting = timeOfDay === "morning" ? "Good morning" : "Good day";

  return (
    <h1>
      {greeting}, {name}!
    </h1>
  );
}

// Usage
<Greeting
  name="Taylor"
  timeOfDay={new Date().getHours() < 12 ? "morning" : "day"}
/>;
```

## The "Local Mutation" Exception üîÑ

There's one exception to the "no mutation" rule: **local variables** created during rendering.

```jsx
function ItemList({ items }) {
  // ‚úÖ This is OK! We're only changing a NEW array we just created
  const processedItems = [];

  for (let i = 0; i < items.length; i++) {
    processedItems.push(<li key={i}>{items[i].toUpperCase()}</li>);
  }

  return <ul>{processedItems}</ul>;
}
```

This is fine because:

1. You created the `processedItems` array from scratch
2. No other component can see or access this array
3. The changes are confined to this single render

It's like making notes on a scratch paper while solving a math problem - the scratch paper didn't exist before you started, and you'll throw it away when you're done.

## Where to Put Side Effects ‚Ü™Ô∏è

Sometimes you actually need to change things (update a database, fetch data, etc). These are called "side effects" and belong in specific places:

### 1. Event Handlers - The Best Place

```jsx
function SaveButton({ document }) {
  // ‚úÖ Perfect place for side effects
  function handleSave() {
    // Side effect in an event handler is good!
    saveToDatabase(document);
    showNotification("Saved!");
  }

  return <button onClick={handleSave}>Save Document</button>;
}
```

### 2. useEffect - For Effects After Rendering

```jsx
function AutoSavingField({ text, onSave }) {
  // ‚úÖ Side effect properly contained in useEffect
  useEffect(() => {
    // This runs after render, not during
    const timeoutId = setTimeout(() => {
      onSave(text);
    }, 2000);

    return () => clearTimeout(timeoutId);
  }, [text, onSave]);

  return <textarea value={text} />;
}
```

## Common Impure Component Mistakes üö´

### Mistake 1: Direct DOM Manipulation

```jsx
// ‚ùå BAD: Bypassing React to change the DOM
function Header({ title }) {
  // Don't do this! Let React handle the DOM
  document.title = title;
  document.getElementById("header").className = "active";

  return <h1 id="header">{title}</h1>;
}

// ‚úÖ GOOD: Let React handle it
function Header({ title }) {
  // Side effect belongs in useEffect
  useEffect(() => {
    document.title = title;
  }, [title]);

  // Use props for className
  return <h1 className="active">{title}</h1>;
}
```

### Mistake 2: Fetching Inside Render

```jsx
// ‚ùå BAD: Data fetching during render
function UserProfile({ userId }) {
  // This runs during render! Big problem!
  const userData = fetchUserData(userId);

  return <div>{userData.name}</div>;
}

// ‚úÖ GOOD: Fetching with useEffect
function UserProfile({ userId }) {
  const [userData, setUserData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Proper place for data fetching
    async function fetchData() {
      setIsLoading(true);
      const data = await fetchUserData(userId);
      setUserData(data);
      setIsLoading(false);
    }

    fetchData();
  }, [userId]);

  if (isLoading) return <div>Loading...</div>;
  return <div>{userData.name}</div>;
}
```

### Mistake 3: Using or Changing Global Variables

```jsx
// ‚ùå BAD: Using global state directly
const globalSettings = { theme: "dark" };

function ThemeDisplay() {
  // Depends on global variable outside React
  return <div>Current theme: {globalSettings.theme}</div>;
}

// ‚úÖ GOOD: Pass as props or use context
function ThemeDisplay({ theme }) {
  // Component explicitly receives all its inputs
  return <div>Current theme: {theme}</div>;
}
```

## Finding Impure Components with StrictMode üîç

React includes a helpful development tool called "StrictMode" that helps find impure components:

```jsx
// Add this at the top level of your app
<React.StrictMode>
  <App />
</React.StrictMode>
```

StrictMode works by:

- Running your component functions twice during development
- Running your effects twice
- If your components are pure, everything should still work fine!
- If they're impure, you'll see strange behavior, helping you find bugs

It's like a metal detector for impure components.

## Visual Analogy: Pure Components as Vending Machines üß†

A pure component is like a vending machine:

1. You put in money and select an item (inputs/props)
2. It always gives you the expected product (same output)
3. It doesn't change anything else around it
4. It doesn't matter how many times you use it - same input, same output

In contrast, an impure component is like a vending machine that:

- Sometimes gives different items for the same selection
- Changes the temperature in the room
- Depends on what other people bought earlier
- Generally behaves unpredictably

## Summary: Why Purity Matters

Pure components are the foundation of React's design philosophy:

- They make your app more predictable and easier to debug
- They enable React's performance optimizations
- They make testing much simpler
- They prevent an entire class of bugs related to side effects
- They prepare your app for advanced React features

Remember: Return the same JSX for the same inputs, and don't change pre-existing data during render. Put all side effects in event handlers or useEffect.

By following these principles, you'll build more reliable and maintainable React applications.
