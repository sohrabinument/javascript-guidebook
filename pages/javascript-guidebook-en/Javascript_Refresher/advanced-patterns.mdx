# Master JavaScript Patterns ğŸš€

Transform your JavaScript skills from good to extraordinary! This guide teaches you the most powerful coding patterns used by professional developers worldwide. Each pattern includes simple explanations, visual examples, and real-world use cases.

> ğŸ’¡ **Perfect for:** Beginners to advanced developers, non-native English speakers, interview preparation, and building production-ready applications.

---

## ğŸ¯ Why Learn These Patterns?

| Benefit                | What It Means                                 | Real Example                                   |
| ---------------------- | --------------------------------------------- | ---------------------------------------------- |
| **Clean Code**         | Write code that's easy to read and understand | Your teammate can modify your code in 6 months |
| **Less Bugs**          | Prevent common mistakes before they happen    | No more "undefined is not a function" errors   |
| **Faster Development** | Reuse proven solutions instead of reinventing | Copy-paste your own tested modules             |
| **Career Growth**      | Speak the language of senior developers       | Pass technical interviews with confidence      |

---

## 1. Module Pattern ğŸ—‚ï¸

### ğŸ“ Simple Explanation

Keep your code organized like files in folders. Hide private details, show only what others need.

### ğŸŒ Real-World Analogy

Think of a **bank account**:

- You can check balance âœ…
- You can deposit money âœ…
- You **cannot** directly change the balance âŒ

### ğŸ’» Code Example

```js
// âœ… Good: Module Pattern
const BankAccount = (function () {
  let balance = 0; // ğŸ”’ Private - nobody can touch this directly

  return {
    // ğŸŒ Public methods - available to everyone
    deposit(amount) {
      if (amount > 0) {
        balance += amount;
        return `Deposited $${amount}. New balance: $${balance}`;
      }
      return "Amount must be positive";
    },

    withdraw(amount) {
      if (amount <= balance) {
        balance -= amount;
        return `Withdrew $${amount}. Remaining balance: $${balance}`;
      }
      return "Insufficient funds";
    },

    getBalance() {
      return balance;
    },
  };
})();

// Usage
console.log(BankAccount.deposit(100)); // "Deposited $100. New balance: $100"
console.log(BankAccount.withdraw(30)); // "Withdrew $30. Remaining balance: $70"
console.log(BankAccount.getBalance()); // 70

// âŒ This won't work - balance is private
console.log(BankAccount.balance); // undefined
```

### ğŸ·ï¸ Class Example

```js
// Using a class to encapsulate module logic
class BankAccount {
  #balance = 0; // Private field (ES2022+)

  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
      return `Deposited $${amount}. New balance: $${this.#balance}`;
    }
    return "Amount must be positive";
  }

  withdraw(amount) {
    if (amount <= this.#balance) {
      this.#balance -= amount;
      return `Withdrew $${amount}. Remaining balance: $${this.#balance}`;
    }
    return "Insufficient funds";
  }

  getBalance() {
    return this.#balance;
  }
}

// Usage
const myAccount = new BankAccount();
console.log(myAccount.deposit(100)); // Deposited $100. New balance: $100
console.log(myAccount.withdraw(30)); // Withdrew $30. Remaining balance: $70
console.log(myAccount.getBalance()); // 70
// console.log(myAccount.#balance); // âŒ Error: Private field
```

> **Explanation:**
>
> - The `#balance` field is privateâ€”only accessible inside the class.
> - Methods like `deposit`, `withdraw`, and `getBalance` are public.
> - This is a modern, class-based way to achieve encapsulation (like a module).

### ğŸš¨ Common Mistakes

```js
// âŒ Wrong - forgot to return an object
const BadModule = (function () {
  let data = "secret";
  // Missing return statement!
})();

// âŒ Wrong - exposed private variable
const BadModule2 = (function () {
  let secret = "password";
  return {
    secret, // Don't do this!
    getSecret() {
      return secret;
    },
  };
})();
```

> **Explanation:**
>
> - In the first example, nothing is returned, so you can't use the module at all.
> - In the second, the private variable `secret` is exposed, which defeats the purpose of using a module for privacy.

### âœ… When to Use

- Building a calculator
- Creating a shopping cart
- Managing user authentication
- Any time you need private variables

---

## 2. Revealing Module Pattern ğŸ”

### ğŸ“ Simple Explanation

Write all your functions first, then decide which ones to share with the world.

### ğŸŒ Real-World Analogy

Like a **restaurant kitchen**: Chefs prepare food using many tools and steps, but customers only see the final dishes on the menu.

### ğŸ’» Code Example

```js
const Calculator = (function () {
  // ğŸ”’ All functions are private by default
  function add(a, b) {
    return a + b;
  }

  function subtract(a, b) {
    return a - b;
  }

  function multiply(a, b) {
    return a * b;
  }

  function divide(a, b) {
    if (b === 0) {
      throw new Error("Cannot divide by zero");
    }
    return a / b;
  }

  // ğŸ”’ Private helper function
  function validateNumbers(a, b) {
    return typeof a === "number" && typeof b === "number";
  }

  // ğŸŒ Only reveal what you want to be public
  return {
    add, // Revealed âœ…
    subtract, // Revealed âœ…
    multiply, // Revealed âœ…
    divide, // Revealed âœ…
    // validateNumbers stays private ğŸ”’
  };
})();

// Usage
console.log(Calculator.add(5, 3)); // 8
console.log(Calculator.multiply(4, 7)); // 28
console.log(Calculator.validateNumbers); // undefined (private)
```

> **Explanation:**
>
> - All the math functions are private by default, so you control exactly what gets exposed.
> - Only the functions you return (`add`, `subtract`, `multiply`, `divide`) are available to users.
> - The helper function `validateNumbers` is hidden, just like a chef's secret recipe in a restaurant kitchen!

### ğŸ†š Module vs Revealing Module

| Module Pattern                         | Revealing Module Pattern                |
| -------------------------------------- | --------------------------------------- |
| Define public methods in return object | Define all functions first, then reveal |
| Mix private and public definitions     | Clear separation of concerns            |
| Can be harder to read                  | Very clear structure                    |

---

## 3. Singleton Pattern ğŸ‘‘

### ğŸ“ Simple Explanation

Ensure only ONE instance of something exists in your entire application.

### ğŸŒ Real-World Analogy

Like a **country's president**: There can only be one president at a time, no matter how many times you ask "who is the president?"

### ğŸ’» Code Example

```js
const AppConfig = (function () {
  let instance = null;
  let config = {};

  function createInstance() {
    return {
      set(key, value) {
        config[key] = value;
      },
      get(key) {
        return config[key];
      },
      getAll() {
        return { ...config }; // Return copy, not original
      },
    };
  }

  return {
    getInstance() {
      if (instance === null) {
        instance = createInstance();
        console.log("ğŸ”¥ New config instance created");
      } else {
        console.log("â™»ï¸ Returning existing config instance");
      }
      return instance;
    },
  };
})();

// Usage
const config1 = AppConfig.getInstance(); // ğŸ”¥ New config instance created
const config2 = AppConfig.getInstance(); // â™»ï¸ Returning existing config instance

config1.set("theme", "dark");
config1.set("language", "en");

console.log(config2.get("theme")); // "dark"
console.log(config1 === config2); // true - same instance!
```

### ğŸ·ï¸ Class Example

```js
class AppConfig {
  static #instance;
  #config = {};

  constructor() {
    if (AppConfig.#instance) {
      return AppConfig.#instance;
    }
    AppConfig.#instance = this;
  }

  set(key, value) {
    this.#config[key] = value;
  }

  get(key) {
    return this.#config[key];
  }

  getAll() {
    return { ...this.#config };
  }
}

// Usage
const configA = new AppConfig();
const configB = new AppConfig();
configA.set("theme", "dark");
console.log(configB.get("theme")); // 'dark'
console.log(configA === configB); // true
```

> **Explanation:**
>
> - No matter how many times you call `getInstance`, you always get the same object.
> - This is like having only one president in a countryâ€”there's only one source of truth for your app's configuration.
> - Any changes made through one reference are reflected everywhere.

### ğŸ¯ Perfect Use Cases

- Application settings/configuration
- Database connections
- Logging services
- Shopping cart in e-commerce
- User authentication state

### âš ï¸ Be Careful

Singletons can make testing difficult. Use them only when you truly need ONE instance.

---

## 4. Factory Pattern ğŸ­

### ğŸ“ Simple Explanation

A function that creates different types of objects based on what you ask for.

### ğŸŒ Real-World Analogy

Like a **car factory**: Give it specifications (SUV, sedan, truck), and it builds the right type of car for you.

### ğŸ’» Code Example

```js
// ğŸ­ Vehicle Factory
function VehicleFactory(type, options = {}) {
  const vehicles = {
    car: {
      type: "Car",
      wheels: 4,
      doors: options.doors || 4,
      start() {
        return `ğŸš— Car engine started!`;
      },
      honk() {
        return `ğŸ”Š Beep beep!`;
      },
    },

    motorcycle: {
      type: "Motorcycle",
      wheels: 2,
      doors: 0,
      start() {
        return `ğŸï¸ Motorcycle engine roared!`;
      },
      honk() {
        return `ğŸ”Š Vroom vroom!`;
      },
    },

    truck: {
      type: "Truck",
      wheels: options.wheels || 6,
      doors: options.doors || 2,
      start() {
        return `ğŸš› Truck engine rumbled!`;
      },
      honk() {
        return `ğŸ”Š HOOOONK!`;
      },
    },
  };

  const vehicle = vehicles[type];
  if (!vehicle) {
    throw new Error(`âŒ Vehicle type "${type}" not supported`);
  }

  return {
    ...vehicle,
    info() {
      return `${this.type} with ${this.wheels} wheels and ${this.doors} doors`;
    },
  };
}

// Usage
const myCar = VehicleFactory("car", { doors: 2 });
const myBike = VehicleFactory("motorcycle");
const myTruck = VehicleFactory("truck", { wheels: 8 });

console.log(myCar.info()); // "Car with 4 wheels and 2 doors"
console.log(myCar.start()); // "ğŸš— Car engine started!"
console.log(myBike.honk()); // "ğŸ”Š Vroom vroom!"
```

### ğŸ·ï¸ Class Example

```js
class Vehicle {
  constructor(type, options = {}) {
    this.type = type;
    this.wheels =
      options.wheels || (type === "car" ? 4 : type === "motorcycle" ? 2 : 6);
    this.doors =
      options.doors || (type === "car" ? 4 : type === "truck" ? 2 : 0);
  }

  start() {
    return `${this.type} engine started!`;
  }

  info() {
    return `${this.type} with ${this.wheels} wheels and ${this.doors} doors`;
  }
}

class VehicleFactory {
  static createVehicle(type, options) {
    return new Vehicle(type, options);
  }
}

// Usage
const car = VehicleFactory.createVehicle("car", { doors: 2 });
const bike = VehicleFactory.createVehicle("motorcycle");
console.log(car.info()); // car with 4 wheels and 2 doors
console.log(bike.start()); // motorcycle engine started!
```

> **Explanation:**
>
> - The factory function builds different types of vehicles based on the `type` you provide.
> - Each vehicle has its own methods and properties, just like a real car, motorcycle, or truck from a factory.
> - This pattern is great for creating many similar objects with small differences.

### ğŸ¯ When to Use Factory Pattern

- Creating UI components (buttons, modals, forms)
- Building different types of users (admin, regular, guest)
- Generating various file formats (PDF, Excel, Word)
- Creating game characters with different abilities

---

## 5. Observer Pattern ğŸ‘€

### ğŸ“ Simple Explanation

When something interesting happens, automatically tell everyone who wants to know.

### ğŸŒ Real-World Analogy

Like **YouTube subscriptions**: When your favorite channel uploads a video, YouTube notifies all subscribers automatically.

### ğŸ’» Code Example

```js
class NewsChannel {
  constructor(name) {
    this.name = name;
    this.subscribers = [];
  }

  // ğŸ“ Subscribe to get notifications
  subscribe(observer) {
    this.subscribers.push(observer);
    console.log(`ğŸ“º ${observer.name} subscribed to ${this.name}`);
  }

  // ğŸš« Stop getting notifications
  unsubscribe(observer) {
    this.subscribers = this.subscribers.filter((sub) => sub !== observer);
    console.log(`ğŸ“º ${observer.name} unsubscribed from ${this.name}`);
  }

  // ğŸ“¢ Tell everyone about breaking news
  publishNews(news) {
    console.log(`\nğŸ”¥ BREAKING: ${news}`);
    this.subscribers.forEach((subscriber) => {
      subscriber.notify(news, this.name);
    });
  }
}

class Subscriber {
  constructor(name) {
    this.name = name;
  }

  notify(news, channelName) {
    console.log(`ğŸ“± ${this.name} received: "${news}" from ${channelName}`);
  }
}

// Usage
const techNews = new NewsChannel("Tech Daily");
const alice = new Subscriber("Alice");
const bob = new Subscriber("Bob");
const charlie = new Subscriber("Charlie");

// Subscribe to notifications
techNews.subscribe(alice);
techNews.subscribe(bob);
techNews.subscribe(charlie);

// Publish news - everyone gets notified!
techNews.publishNews("New iPhone released!");
techNews.publishNews("JavaScript 2024 features announced!");

// Bob unsubscribes
techNews.unsubscribe(bob);
techNews.publishNews("React 19 is here!"); // Only Alice and Charlie get this
```

### ğŸ·ï¸ Class Example

```js
class Subject {
  constructor() {
    this.observers = [];
  }

  subscribe(observer) {
    this.observers.push(observer);
  }

  unsubscribe(observer) {
    this.observers = this.observers.filter((obs) => obs !== observer);
  }

  notify(data) {
    this.observers.forEach((observer) => observer.update(data));
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }

  update(data) {
    console.log(`${this.name} received: ${data}`);
  }
}

// Usage
const news = new Subject();
const alice = new Observer("Alice");
const bob = new Observer("Bob");
news.subscribe(alice);
news.subscribe(bob);
news.notify("New JavaScript release!");
// Alice received: New JavaScript release!
// Bob received: New JavaScript release!
```

> **Explanation:**
>
> - Subscribers sign up to get updates from the news channel.
> - When the channel publishes news, all subscribers are notified automatically.
> - This is just like YouTube or Twitter notifications in real life!

### ğŸ¯ Real-World Applications

- **Social media** notifications
- **E-commerce** price alerts
- **Stock market** updates
- **Gaming** achievement systems
- **Email** newsletter systems

---

## 6. Debounce & Throttle â³

### ğŸ“ Simple Explanation

Control how often functions run to improve performance and user experience.

### ğŸŒ Real-World Analogies

**Debounce** = **Elevator**: Waits a few seconds after the last person presses a button before moving.

**Throttle** = **Traffic light**: No matter how many cars arrive, it only changes every 30 seconds.

### ğŸ’» Debounce Example

```js
// ğŸ” Search with Debounce
function debounce(func, delay) {
  let timeoutId;
  return function (...args) {
    // Cancel previous timer
    clearTimeout(timeoutId);

    // Start new timer
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// Simulate expensive search function
function searchAPI(query) {
  console.log(`ğŸ” Searching for: "${query}"`);
  // Imagine this makes an API call
}

const debouncedSearch = debounce(searchAPI, 500); // Wait 500ms

// Simulate user typing
console.log("User starts typing...");
debouncedSearch("j"); // Cancelled
debouncedSearch("ja"); // Cancelled
debouncedSearch("jav"); // Cancelled
debouncedSearch("java"); // Cancelled
debouncedSearch("javascript"); // âœ… This runs after 500ms of no typing

setTimeout(() => {
  console.log("User continues typing...");
  debouncedSearch("javascrip"); // Cancelled
  debouncedSearch("javascript patterns"); // âœ… This runs
}, 2000);
```

### ğŸ’» Throttle Example

```js
// ğŸ“Š Scroll Progress with Throttle
function throttle(func, limit) {
  let inThrottle;
  return function (...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

function updateScrollProgress() {
  const scrolled =
    (window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100;
  console.log(`ğŸ“Š Scroll progress: ${Math.round(scrolled)}%`);
}

const throttledScroll = throttle(updateScrollProgress, 250); // Max once per 250ms

// Add to page (uncomment to test)
// window.addEventListener('scroll', throttledScroll);
```

### ğŸ·ï¸ Class Example (Debounce)

```js
class Debouncer {
  constructor(fn, delay) {
    this.fn = fn;
    this.delay = delay;
    this.timeout = null;
  }

  call(...args) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.fn(...args), this.delay);
  }
}

// Usage
const debouncedLog = new Debouncer((msg) => console.log(msg), 500);
debouncedLog.call("Hello");
debouncedLog.call("Hello again"); // Only this runs after 500ms
```

### ğŸ†š Debounce vs Throttle

| Situation          | Use Debounce                              | Use Throttle           |
| ------------------ | ----------------------------------------- | ---------------------- |
| **Search box**     | âœ… Wait for user to stop typing           | âŒ Too many API calls  |
| **Button click**   | âœ… Prevent double-clicks                  | âŒ May miss clicks     |
| **Scroll events**  | âŒ May never fire if user keeps scrolling | âœ… Regular updates     |
| **Resize events**  | âœ… Wait for user to finish resizing       | âŒ May miss final size |
| **Mouse movement** | âŒ May never fire                         | âœ… Smooth tracking     |

---

## 7. Currying & Partial Application ğŸ›

### ğŸ“ Simple Explanation

Break complex functions into smaller, reusable pieces.

### ğŸŒ Real-World Analogy

Like a **sandwich shop**: Instead of one giant "make any sandwich" machine, you have separate stations for bread â†’ meat â†’ cheese â†’ vegetables.

### ğŸ’» Currying Example

```js
// ğŸ› Traditional function
function traditionalMultiply(a, b, c) {
  return a * b * c;
}

// ğŸ”— Curried version - one parameter at a time
function curriedMultiply(a) {
  return function (b) {
    return function (c) {
      return a * b * c;
    };
  };
}

// ğŸš€ Modern arrow function version
const multiply = (a) => (b) => (c) => a * b * c;

// Usage examples
console.log(traditionalMultiply(2, 3, 4)); // 24

// Curried - step by step
const step1 = curriedMultiply(2); // Returns function waiting for 'b'
const step2 = step1(3); // Returns function waiting for 'c'
const result = step2(4); // Returns final result: 24

// Or chain it all together
console.log(curriedMultiply(2)(3)(4)); // 24
console.log(multiply(2)(3)(4)); // 24

// ğŸ¯ The real power - create specialized functions
const double = multiply(2); // Multiply by 2
const triple = multiply(3); // Multiply by 3

const doubleAndSquare = double(4); // 2 * 4 * ?
const tripleAndSquare = triple(4); // 3 * 4 * ?

console.log(doubleAndSquare(5)); // 2 * 4 * 5 = 40
console.log(tripleAndSquare(5)); // 3 * 4 * 5 = 60
```

### ğŸ¯ Practical Applications

```js
// ğŸŒ API Request Builder
const apiRequest = (method) => (url) => (data) => {
  return fetch(url, {
    method: method,
    headers: { "Content-Type": "application/json" },
    body: data ? JSON.stringify(data) : null,
  });
};

// Create specialized functions
const get = apiRequest("GET");
const post = apiRequest("POST");
const put = apiRequest("PUT");

// Use them
const getUsers = get("/api/users");
const createUser = post("/api/users");

getUsers(); // GET /api/users
createUser({ name: "John" }); // POST /api/users with data

// ğŸ’° Discount Calculator
const discount = (percentage) => (price) => {
  return price - (price * percentage) / 100;
};

const tenPercentOff = discount(10);
const twentyPercentOff = discount(20);

console.log(tenPercentOff(100)); // 90
console.log(twentyPercentOff(100)); // 80
```

### ğŸ·ï¸ Class Example

```js
// ğŸ› Traditional function
function traditionalMultiply(a, b, c) {
  return a * b * c;
}

// ğŸ”— Curried version - one parameter at a time
function curriedMultiply(a) {
  return function (b) {
    return function (c) {
      return a * b * c;
    };
  };
}

// ğŸš€ Modern arrow function version
const multiply = (a) => (b) => (c) => a * b * c;

// Usage examples
console.log(traditionalMultiply(2, 3, 4)); // 24

// Curried - step by step
const step1 = curriedMultiply(2); // Returns function waiting for 'b'
const step2 = step1(3); // Returns function waiting for 'c'
const result = step2(4); // Returns final result: 24

// Or chain it all together
console.log(curriedMultiply(2)(3)(4)); // 24
console.log(multiply(2)(3)(4)); // 24

// ğŸ¯ The real power - create specialized functions
const double = multiply(2); // Multiply by 2
const triple = multiply(3); // Multiply by 3

const doubleAndSquare = double(4); // 2 * 4 * ?
const tripleAndSquare = triple(4); // 3 * 4 * ?

console.log(doubleAndSquare(5)); // 2 * 4 * 5 = 40
console.log(tripleAndSquare(5)); // 3 * 4 * 5 = 60
```

> **Explanation:**
>
> - Currying breaks a function into smaller functions, each taking one argument.
> - This lets you create specialized functions (like `double` or `triple`) easily.
> - It's like a sandwich shop where each station adds one ingredient at a time.

### ğŸ¯ Practical Applications

```js
// ğŸŒ API Request Builder
const apiRequest = (method) => (url) => (data) => {
  return fetch(url, {
    method: method,
    headers: { "Content-Type": "application/json" },
    body: data ? JSON.stringify(data) : null,
  });
};

// Create specialized functions
const get = apiRequest("GET");
const post = apiRequest("POST");
const put = apiRequest("PUT");

// Use them
const getUsers = get("/api/users");
const createUser = post("/api/users");

getUsers(); // GET /api/users
createUser({ name: "John" }); // POST /api/users with data

// ğŸ’° Discount Calculator
const discount = (percentage) => (price) => {
  return price - (price * percentage) / 100;
};

const tenPercentOff = discount(10);
const twentyPercentOff = discount(20);

console.log(tenPercentOff(100)); // 90
console.log(twentyPercentOff(100)); // 80
```

> **Explanation:**
>
> - Currying lets you build reusable, specialized functions for things like API requests or discounts.
> - You can create a `get` or `post` function once, then reuse it everywhere.
> - This is like having a sandwich shop where you can pre-make the bread or sauce for every order.

---

## 8. Memoization ğŸ§ 

### ğŸ“ Simple Explanation

Remember the results of expensive calculations so you don't have to do them again.

### ğŸŒ Real-World Analogy

Like a **math student's cheat sheet**: Once you calculate 7 Ã— 8 = 56, you write it down and never calculate it again.

### ğŸ’» Basic Memoization

```js
// ğŸ§  Simple memoization function
function memoize(fn) {
  const cache = new Map();

  return function (...args) {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      console.log(`ğŸ’¾ Cache hit for ${key}`);
      return cache.get(key);
    }

    console.log(`âš¡ Computing result for ${key}`);
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// ğŸ”¢ Expensive calculation example
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFibonacci = memoize(fibonacci);

console.log(memoizedFibonacci(10)); // âš¡ Computing... (takes time)
console.log(memoizedFibonacci(10)); // ğŸ’¾ Cache hit! (instant)
console.log(memoizedFibonacci(15)); // âš¡ Computing... (but reuses cached values)
```

### ğŸ’» Advanced Memoization with Expiry

```js
// ğŸ•’ Memoization with expiration
function memoizeWithExpiry(fn, ttl = 60000) {
  // Default 1 minute
  const cache = new Map();

  return function (...args) {
    const key = JSON.stringify(args);
    const now = Date.now();

    if (cache.has(key)) {
      const { result, timestamp } = cache.get(key);

      if (now - timestamp < ttl) {
        console.log(`ğŸ’¾ Fresh cache hit for ${key}`);
        return result;
      } else {
        console.log(`ğŸ—‘ï¸ Cache expired for ${key}`);
        cache.delete(key);
      }
    }

    console.log(`âš¡ Computing fresh result for ${key}`);
    const result = fn.apply(this, args);
    cache.set(key, { result, timestamp: now });
    return result;
  };
}

// ğŸŒ API call example
async function fetchUser(id) {
  console.log(`ğŸŒ Making API call for user ${id}`);
  // Simulate API delay
  await new Promise((resolve) => setTimeout(resolve, 1000));
  return { id, name: `User ${id}`, email: `user${id}@example.com` };
}

const memoizedFetchUser = memoizeWithExpiry(fetchUser, 30000); // Cache for 30 seconds

// Usage
memoizedFetchUser(1).then(console.log); // ğŸŒ API call
memoizedFetchUser(1).then(console.log); // ğŸ’¾ Cache hit
```

### ğŸ¯ Perfect Use Cases

- **API responses** that don't change often
- **Complex calculations** (math, algorithms)
- **Database queries** with same parameters
- **Image processing** results
- **Search results** for recent queries

### ğŸ·ï¸ Class Example

```js
// ğŸ§  Simple memoization function
function memoize(fn) {
  const cache = new Map();

  return function (...args) {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      console.log(`ğŸ’¾ Cache hit for ${key}`);
      return cache.get(key);
    }

    console.log(`âš¡ Computing result for ${key}`);
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// ğŸ”¢ Expensive calculation example
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFibonacci = memoize(fibonacci);

console.log(memoizedFibonacci(10)); // âš¡ Computing... (takes time)
console.log(memoizedFibonacci(10)); // ğŸ’¾ Cache hit! (instant)
console.log(memoizedFibonacci(15)); // âš¡ Computing... (but reuses cached values)
```

> **Explanation:**
>
> - The first time you call `memoizedFibonacci(10)`, it does all the work and stores the result.
> - The next time, it just grabs the answer from memoryâ€”no need to recalculate!
> - This is like a student writing down the answer to a hard math problem so they never have to solve it again.

### ğŸ’» Advanced Memoization with Expiry

```js
// ğŸ•’ Memoization with expiration
function memoizeWithExpiry(fn, ttl = 60000) {
  // Default 1 minute
  const cache = new Map();

  return function (...args) {
    const key = JSON.stringify(args);
    const now = Date.now();

    if (cache.has(key)) {
      const { result, timestamp } = cache.get(key);

      if (now - timestamp < ttl) {
        console.log(`ğŸ’¾ Fresh cache hit for ${key}`);
        return result;
      } else {
        console.log(`ğŸ—‘ï¸ Cache expired for ${key}`);
        cache.delete(key);
      }
    }

    console.log(`âš¡ Computing fresh result for ${key}`);
    const result = fn.apply(this, args);
    cache.set(key, { result, timestamp: now });
    return result;
  };
}

// ğŸŒ API call example
async function fetchUser(id) {
  console.log(`ğŸŒ Making API call for user ${id}`);
  // Simulate API delay
  await new Promise((resolve) => setTimeout(resolve, 1000));
  return { id, name: `User ${id}`, email: `user${id}@example.com` };
}

const memoizedFetchUser = memoizeWithExpiry(fetchUser, 30000); // Cache for 30 seconds

// Usage
memoizedFetchUser(1).then(console.log); // ğŸŒ API call
memoizedFetchUser(1).then(console.log); // ğŸ’¾ Cache hit
```

> **Explanation:**
>
> - This version of memoization forgets old answers after a set time (like 30 seconds).
> - It's perfect for things like API calls where the data might change after a while.
> - This is like a grocery store that throws out old food after a day to keep things fresh!

### ğŸ¯ Perfect Use Cases

- **API responses** that don't change often
- **Complex calculations** (math, algorithms)
- **Database queries** with same parameters
- **Image processing** results
- **Search results** for recent queries

## ğŸ—‚ï¸ Pattern Comparison Guide

| Pattern              | Complexity | Use When                       | Avoid When                 |
| -------------------- | ---------- | ------------------------------ | -------------------------- |
| **Module**           | ğŸŸ¢ Easy    | Need private variables         | Simple scripts             |
| **Revealing Module** | ğŸŸ¢ Easy    | Want clear structure           | Very small modules         |
| **Singleton**        | ğŸŸ¡ Medium  | Need ONE instance              | Need multiple instances    |
| **Factory**          | ğŸŸ¡ Medium  | Creating similar objects       | Objects are very different |
| **Observer**         | ğŸŸ¡ Medium  | Event systems                  | Simple notifications       |
| **Debounce**         | ğŸŸ¢ Easy    | User input delays              | Need immediate response    |
| **Throttle**         | ğŸŸ¢ Easy    | Limit frequency                | Need all events            |
| **Currying**         | ğŸ”´ Hard    | Building specialized functions | Simple operations          |
| **Memoization**      | ğŸŸ¡ Medium  | Expensive calculations         | Fast operations            |

---

## ğŸš€ Next Steps

### ğŸ“š Practice Projects

1. **Todo App**: Use Module pattern for task management
2. **Theme Switcher**: Implement Singleton for app settings
3. **Form Validator**: Apply Factory pattern for different validators
4. **Real-time Chat**: Use Observer pattern for message updates
5. **Search App**: Combine Debounce with Memoization

### ğŸ”— Additional Resources

- [JavaScript Design Patterns - Addy Osmani](https://addyosmani.com/resources/essentialjsdesignpatterns/book/)
- [MDN Web Docs - JavaScript Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)
- [Patterns.dev - Modern Web App Patterns](https://patterns.dev/)
- [Refactoring.Guru - Design Patterns](https://refactoring.guru/design-patterns/javascript)

### ğŸ’¬ Community

- Join JavaScript communities on Discord/Reddit
- Practice on coding platforms like LeetCode, Codewars
- Build projects and share on GitHub
- Write blog posts about what you learn

---

## ğŸ“‹ Quick Reference Cheat Sheet

```js
// Module Pattern
const MyModule = (function () {
  let private = "secret";
  return { getPrivate: () => private };
})();

// Singleton Pattern
const Singleton = (function () {
  let instance;
  return { getInstance: () => instance || (instance = {}) };
})();

// Factory Pattern
const Factory = (type) => (type === "A" ? { a: 1 } : { b: 2 });

// Observer Pattern
class Subject {
  constructor() {
    this.observers = [];
  }
  notify(data) {
    this.observers.forEach((fn) => fn(data));
  }
}

// Debounce
const debounce = (fn, delay) => {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn(...args), delay);
  };
};

// Throttle
const throttle = (fn, limit) => {
  let inThrottle;
  return (...args) => {
    if (!inThrottle) {
      fn(...args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
};

// Currying
const curry = (a) => (b) => (c) => a + b + c;

// Memoization
const memoize = (fn) => {
  const cache = {};
  return (arg) => cache[arg] || (cache[arg] = fn(arg));
};
```

> **Explanation:**
>
> - This cheat sheet gives you a quick reference for each pattern.
> - Use it as a template for your own projects or interview prep!

---

**Happy coding! ğŸ‰** Remember: The best pattern is the one that solves your specific problem clearly and simply.
