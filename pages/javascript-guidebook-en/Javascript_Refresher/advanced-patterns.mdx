# Master JavaScript Patterns 🚀

Transform your JavaScript skills from good to extraordinary! This guide teaches you the most powerful coding patterns used by professional developers worldwide. Each pattern includes simple explanations, visual examples, and real-world use cases.

> 💡 **Perfect for:** Beginners to advanced developers, non-native English speakers, interview preparation, and building production-ready applications.

---

## 🎯 Why Learn These Patterns?

| Benefit                | What It Means                                 | Real Example                                   |
| ---------------------- | --------------------------------------------- | ---------------------------------------------- |
| **Clean Code**         | Write code that's easy to read and understand | Your teammate can modify your code in 6 months |
| **Less Bugs**          | Prevent common mistakes before they happen    | No more "undefined is not a function" errors   |
| **Faster Development** | Reuse proven solutions instead of reinventing | Copy-paste your own tested modules             |
| **Career Growth**      | Speak the language of senior developers       | Pass technical interviews with confidence      |

---

## 1. Module Pattern 🗂️

### 📝 Simple Explanation

Keep your code organized like files in folders. Hide private details, show only what others need.

### 🌍 Real-World Analogy

Think of a **bank account**:

- You can check balance ✅
- You can deposit money ✅
- You **cannot** directly change the balance ❌

### 💻 Code Example

```js
// ✅ Good: Module Pattern
const BankAccount = (function () {
  let balance = 0; // 🔒 Private - nobody can touch this directly

  return {
    // 🌐 Public methods - available to everyone
    deposit(amount) {
      if (amount > 0) {
        balance += amount;
        return `Deposited $${amount}. New balance: $${balance}`;
      }
      return "Amount must be positive";
    },

    withdraw(amount) {
      if (amount <= balance) {
        balance -= amount;
        return `Withdrew $${amount}. Remaining balance: $${balance}`;
      }
      return "Insufficient funds";
    },

    getBalance() {
      return balance;
    },
  };
})();

// Usage
console.log(BankAccount.deposit(100)); // "Deposited $100. New balance: $100"
console.log(BankAccount.withdraw(30)); // "Withdrew $30. Remaining balance: $70"
console.log(BankAccount.getBalance()); // 70

// ❌ This won't work - balance is private
console.log(BankAccount.balance); // undefined
```

### 🏷️ Class Example

```js
// Using a class to encapsulate module logic
class BankAccount {
  #balance = 0; // Private field (ES2022+)

  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
      return `Deposited $${amount}. New balance: $${this.#balance}`;
    }
    return "Amount must be positive";
  }

  withdraw(amount) {
    if (amount <= this.#balance) {
      this.#balance -= amount;
      return `Withdrew $${amount}. Remaining balance: $${this.#balance}`;
    }
    return "Insufficient funds";
  }

  getBalance() {
    return this.#balance;
  }
}

// Usage
const myAccount = new BankAccount();
console.log(myAccount.deposit(100)); // Deposited $100. New balance: $100
console.log(myAccount.withdraw(30)); // Withdrew $30. Remaining balance: $70
console.log(myAccount.getBalance()); // 70
// console.log(myAccount.#balance); // ❌ Error: Private field
```

> **Explanation:**
>
> - The `#balance` field is private—only accessible inside the class.
> - Methods like `deposit`, `withdraw`, and `getBalance` are public.
> - This is a modern, class-based way to achieve encapsulation (like a module).

### 🚨 Common Mistakes

```js
// ❌ Wrong - forgot to return an object
const BadModule = (function () {
  let data = "secret";
  // Missing return statement!
})();

// ❌ Wrong - exposed private variable
const BadModule2 = (function () {
  let secret = "password";
  return {
    secret, // Don't do this!
    getSecret() {
      return secret;
    },
  };
})();
```

> **Explanation:**
>
> - In the first example, nothing is returned, so you can't use the module at all.
> - In the second, the private variable `secret` is exposed, which defeats the purpose of using a module for privacy.

### ✅ When to Use

- Building a calculator
- Creating a shopping cart
- Managing user authentication
- Any time you need private variables

---

## 2. Revealing Module Pattern 🔍

### 📝 Simple Explanation

Write all your functions first, then decide which ones to share with the world.

### 🌍 Real-World Analogy

Like a **restaurant kitchen**: Chefs prepare food using many tools and steps, but customers only see the final dishes on the menu.

### 💻 Code Example

```js
const Calculator = (function () {
  // 🔒 All functions are private by default
  function add(a, b) {
    return a + b;
  }

  function subtract(a, b) {
    return a - b;
  }

  function multiply(a, b) {
    return a * b;
  }

  function divide(a, b) {
    if (b === 0) {
      throw new Error("Cannot divide by zero");
    }
    return a / b;
  }

  // 🔒 Private helper function
  function validateNumbers(a, b) {
    return typeof a === "number" && typeof b === "number";
  }

  // 🌐 Only reveal what you want to be public
  return {
    add, // Revealed ✅
    subtract, // Revealed ✅
    multiply, // Revealed ✅
    divide, // Revealed ✅
    // validateNumbers stays private 🔒
  };
})();

// Usage
console.log(Calculator.add(5, 3)); // 8
console.log(Calculator.multiply(4, 7)); // 28
console.log(Calculator.validateNumbers); // undefined (private)
```

> **Explanation:**
>
> - All the math functions are private by default, so you control exactly what gets exposed.
> - Only the functions you return (`add`, `subtract`, `multiply`, `divide`) are available to users.
> - The helper function `validateNumbers` is hidden, just like a chef's secret recipe in a restaurant kitchen!

### 🆚 Module vs Revealing Module

| Module Pattern                         | Revealing Module Pattern                |
| -------------------------------------- | --------------------------------------- |
| Define public methods in return object | Define all functions first, then reveal |
| Mix private and public definitions     | Clear separation of concerns            |
| Can be harder to read                  | Very clear structure                    |

---

## 3. Singleton Pattern 👑

### 📝 Simple Explanation

Ensure only ONE instance of something exists in your entire application.

### 🌍 Real-World Analogy

Like a **country's president**: There can only be one president at a time, no matter how many times you ask "who is the president?"

### 💻 Code Example

```js
const AppConfig = (function () {
  let instance = null;
  let config = {};

  function createInstance() {
    return {
      set(key, value) {
        config[key] = value;
      },
      get(key) {
        return config[key];
      },
      getAll() {
        return { ...config }; // Return copy, not original
      },
    };
  }

  return {
    getInstance() {
      if (instance === null) {
        instance = createInstance();
        console.log("🔥 New config instance created");
      } else {
        console.log("♻️ Returning existing config instance");
      }
      return instance;
    },
  };
})();

// Usage
const config1 = AppConfig.getInstance(); // 🔥 New config instance created
const config2 = AppConfig.getInstance(); // ♻️ Returning existing config instance

config1.set("theme", "dark");
config1.set("language", "en");

console.log(config2.get("theme")); // "dark"
console.log(config1 === config2); // true - same instance!
```

### 🏷️ Class Example

```js
class AppConfig {
  static #instance;
  #config = {};

  constructor() {
    if (AppConfig.#instance) {
      return AppConfig.#instance;
    }
    AppConfig.#instance = this;
  }

  set(key, value) {
    this.#config[key] = value;
  }

  get(key) {
    return this.#config[key];
  }

  getAll() {
    return { ...this.#config };
  }
}

// Usage
const configA = new AppConfig();
const configB = new AppConfig();
configA.set("theme", "dark");
console.log(configB.get("theme")); // 'dark'
console.log(configA === configB); // true
```

> **Explanation:**
>
> - No matter how many times you call `getInstance`, you always get the same object.
> - This is like having only one president in a country—there's only one source of truth for your app's configuration.
> - Any changes made through one reference are reflected everywhere.

### 🎯 Perfect Use Cases

- Application settings/configuration
- Database connections
- Logging services
- Shopping cart in e-commerce
- User authentication state

### ⚠️ Be Careful

Singletons can make testing difficult. Use them only when you truly need ONE instance.

---

## 4. Factory Pattern 🏭

### 📝 Simple Explanation

A function that creates different types of objects based on what you ask for.

### 🌍 Real-World Analogy

Like a **car factory**: Give it specifications (SUV, sedan, truck), and it builds the right type of car for you.

### 💻 Code Example

```js
// 🏭 Vehicle Factory
function VehicleFactory(type, options = {}) {
  const vehicles = {
    car: {
      type: "Car",
      wheels: 4,
      doors: options.doors || 4,
      start() {
        return `🚗 Car engine started!`;
      },
      honk() {
        return `🔊 Beep beep!`;
      },
    },

    motorcycle: {
      type: "Motorcycle",
      wheels: 2,
      doors: 0,
      start() {
        return `🏍️ Motorcycle engine roared!`;
      },
      honk() {
        return `🔊 Vroom vroom!`;
      },
    },

    truck: {
      type: "Truck",
      wheels: options.wheels || 6,
      doors: options.doors || 2,
      start() {
        return `🚛 Truck engine rumbled!`;
      },
      honk() {
        return `🔊 HOOOONK!`;
      },
    },
  };

  const vehicle = vehicles[type];
  if (!vehicle) {
    throw new Error(`❌ Vehicle type "${type}" not supported`);
  }

  return {
    ...vehicle,
    info() {
      return `${this.type} with ${this.wheels} wheels and ${this.doors} doors`;
    },
  };
}

// Usage
const myCar = VehicleFactory("car", { doors: 2 });
const myBike = VehicleFactory("motorcycle");
const myTruck = VehicleFactory("truck", { wheels: 8 });

console.log(myCar.info()); // "Car with 4 wheels and 2 doors"
console.log(myCar.start()); // "🚗 Car engine started!"
console.log(myBike.honk()); // "🔊 Vroom vroom!"
```

### 🏷️ Class Example

```js
class Vehicle {
  constructor(type, options = {}) {
    this.type = type;
    this.wheels =
      options.wheels || (type === "car" ? 4 : type === "motorcycle" ? 2 : 6);
    this.doors =
      options.doors || (type === "car" ? 4 : type === "truck" ? 2 : 0);
  }

  start() {
    return `${this.type} engine started!`;
  }

  info() {
    return `${this.type} with ${this.wheels} wheels and ${this.doors} doors`;
  }
}

class VehicleFactory {
  static createVehicle(type, options) {
    return new Vehicle(type, options);
  }
}

// Usage
const car = VehicleFactory.createVehicle("car", { doors: 2 });
const bike = VehicleFactory.createVehicle("motorcycle");
console.log(car.info()); // car with 4 wheels and 2 doors
console.log(bike.start()); // motorcycle engine started!
```

> **Explanation:**
>
> - The factory function builds different types of vehicles based on the `type` you provide.
> - Each vehicle has its own methods and properties, just like a real car, motorcycle, or truck from a factory.
> - This pattern is great for creating many similar objects with small differences.

### 🎯 When to Use Factory Pattern

- Creating UI components (buttons, modals, forms)
- Building different types of users (admin, regular, guest)
- Generating various file formats (PDF, Excel, Word)
- Creating game characters with different abilities

---

## 5. Observer Pattern 👀

### 📝 Simple Explanation

When something interesting happens, automatically tell everyone who wants to know.

### 🌍 Real-World Analogy

Like **YouTube subscriptions**: When your favorite channel uploads a video, YouTube notifies all subscribers automatically.

### 💻 Code Example

```js
class NewsChannel {
  constructor(name) {
    this.name = name;
    this.subscribers = [];
  }

  // 📝 Subscribe to get notifications
  subscribe(observer) {
    this.subscribers.push(observer);
    console.log(`📺 ${observer.name} subscribed to ${this.name}`);
  }

  // 🚫 Stop getting notifications
  unsubscribe(observer) {
    this.subscribers = this.subscribers.filter((sub) => sub !== observer);
    console.log(`📺 ${observer.name} unsubscribed from ${this.name}`);
  }

  // 📢 Tell everyone about breaking news
  publishNews(news) {
    console.log(`\n🔥 BREAKING: ${news}`);
    this.subscribers.forEach((subscriber) => {
      subscriber.notify(news, this.name);
    });
  }
}

class Subscriber {
  constructor(name) {
    this.name = name;
  }

  notify(news, channelName) {
    console.log(`📱 ${this.name} received: "${news}" from ${channelName}`);
  }
}

// Usage
const techNews = new NewsChannel("Tech Daily");
const alice = new Subscriber("Alice");
const bob = new Subscriber("Bob");
const charlie = new Subscriber("Charlie");

// Subscribe to notifications
techNews.subscribe(alice);
techNews.subscribe(bob);
techNews.subscribe(charlie);

// Publish news - everyone gets notified!
techNews.publishNews("New iPhone released!");
techNews.publishNews("JavaScript 2024 features announced!");

// Bob unsubscribes
techNews.unsubscribe(bob);
techNews.publishNews("React 19 is here!"); // Only Alice and Charlie get this
```

### 🏷️ Class Example

```js
class Subject {
  constructor() {
    this.observers = [];
  }

  subscribe(observer) {
    this.observers.push(observer);
  }

  unsubscribe(observer) {
    this.observers = this.observers.filter((obs) => obs !== observer);
  }

  notify(data) {
    this.observers.forEach((observer) => observer.update(data));
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }

  update(data) {
    console.log(`${this.name} received: ${data}`);
  }
}

// Usage
const news = new Subject();
const alice = new Observer("Alice");
const bob = new Observer("Bob");
news.subscribe(alice);
news.subscribe(bob);
news.notify("New JavaScript release!");
// Alice received: New JavaScript release!
// Bob received: New JavaScript release!
```

> **Explanation:**
>
> - Subscribers sign up to get updates from the news channel.
> - When the channel publishes news, all subscribers are notified automatically.
> - This is just like YouTube or Twitter notifications in real life!

### 🎯 Real-World Applications

- **Social media** notifications
- **E-commerce** price alerts
- **Stock market** updates
- **Gaming** achievement systems
- **Email** newsletter systems

---

## 6. Debounce & Throttle ⏳

### 📝 Simple Explanation

Control how often functions run to improve performance and user experience.

### 🌍 Real-World Analogies

**Debounce** = **Elevator**: Waits a few seconds after the last person presses a button before moving.

**Throttle** = **Traffic light**: No matter how many cars arrive, it only changes every 30 seconds.

### 💻 Debounce Example

```js
// 🔍 Search with Debounce
function debounce(func, delay) {
  let timeoutId;
  return function (...args) {
    // Cancel previous timer
    clearTimeout(timeoutId);

    // Start new timer
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// Simulate expensive search function
function searchAPI(query) {
  console.log(`🔍 Searching for: "${query}"`);
  // Imagine this makes an API call
}

const debouncedSearch = debounce(searchAPI, 500); // Wait 500ms

// Simulate user typing
console.log("User starts typing...");
debouncedSearch("j"); // Cancelled
debouncedSearch("ja"); // Cancelled
debouncedSearch("jav"); // Cancelled
debouncedSearch("java"); // Cancelled
debouncedSearch("javascript"); // ✅ This runs after 500ms of no typing

setTimeout(() => {
  console.log("User continues typing...");
  debouncedSearch("javascrip"); // Cancelled
  debouncedSearch("javascript patterns"); // ✅ This runs
}, 2000);
```

### 💻 Throttle Example

```js
// 📊 Scroll Progress with Throttle
function throttle(func, limit) {
  let inThrottle;
  return function (...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

function updateScrollProgress() {
  const scrolled =
    (window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100;
  console.log(`📊 Scroll progress: ${Math.round(scrolled)}%`);
}

const throttledScroll = throttle(updateScrollProgress, 250); // Max once per 250ms

// Add to page (uncomment to test)
// window.addEventListener('scroll', throttledScroll);
```

### 🏷️ Class Example (Debounce)

```js
class Debouncer {
  constructor(fn, delay) {
    this.fn = fn;
    this.delay = delay;
    this.timeout = null;
  }

  call(...args) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.fn(...args), this.delay);
  }
}

// Usage
const debouncedLog = new Debouncer((msg) => console.log(msg), 500);
debouncedLog.call("Hello");
debouncedLog.call("Hello again"); // Only this runs after 500ms
```

### 🆚 Debounce vs Throttle

| Situation          | Use Debounce                              | Use Throttle           |
| ------------------ | ----------------------------------------- | ---------------------- |
| **Search box**     | ✅ Wait for user to stop typing           | ❌ Too many API calls  |
| **Button click**   | ✅ Prevent double-clicks                  | ❌ May miss clicks     |
| **Scroll events**  | ❌ May never fire if user keeps scrolling | ✅ Regular updates     |
| **Resize events**  | ✅ Wait for user to finish resizing       | ❌ May miss final size |
| **Mouse movement** | ❌ May never fire                         | ✅ Smooth tracking     |

---

## 7. Currying & Partial Application 🍛

### 📝 Simple Explanation

Break complex functions into smaller, reusable pieces.

### 🌍 Real-World Analogy

Like a **sandwich shop**: Instead of one giant "make any sandwich" machine, you have separate stations for bread → meat → cheese → vegetables.

### 💻 Currying Example

```js
// 🍛 Traditional function
function traditionalMultiply(a, b, c) {
  return a * b * c;
}

// 🔗 Curried version - one parameter at a time
function curriedMultiply(a) {
  return function (b) {
    return function (c) {
      return a * b * c;
    };
  };
}

// 🚀 Modern arrow function version
const multiply = (a) => (b) => (c) => a * b * c;

// Usage examples
console.log(traditionalMultiply(2, 3, 4)); // 24

// Curried - step by step
const step1 = curriedMultiply(2); // Returns function waiting for 'b'
const step2 = step1(3); // Returns function waiting for 'c'
const result = step2(4); // Returns final result: 24

// Or chain it all together
console.log(curriedMultiply(2)(3)(4)); // 24
console.log(multiply(2)(3)(4)); // 24

// 🎯 The real power - create specialized functions
const double = multiply(2); // Multiply by 2
const triple = multiply(3); // Multiply by 3

const doubleAndSquare = double(4); // 2 * 4 * ?
const tripleAndSquare = triple(4); // 3 * 4 * ?

console.log(doubleAndSquare(5)); // 2 * 4 * 5 = 40
console.log(tripleAndSquare(5)); // 3 * 4 * 5 = 60
```

### 🎯 Practical Applications

```js
// 🌐 API Request Builder
const apiRequest = (method) => (url) => (data) => {
  return fetch(url, {
    method: method,
    headers: { "Content-Type": "application/json" },
    body: data ? JSON.stringify(data) : null,
  });
};

// Create specialized functions
const get = apiRequest("GET");
const post = apiRequest("POST");
const put = apiRequest("PUT");

// Use them
const getUsers = get("/api/users");
const createUser = post("/api/users");

getUsers(); // GET /api/users
createUser({ name: "John" }); // POST /api/users with data

// 💰 Discount Calculator
const discount = (percentage) => (price) => {
  return price - (price * percentage) / 100;
};

const tenPercentOff = discount(10);
const twentyPercentOff = discount(20);

console.log(tenPercentOff(100)); // 90
console.log(twentyPercentOff(100)); // 80
```

### 🏷️ Class Example

```js
// 🍛 Traditional function
function traditionalMultiply(a, b, c) {
  return a * b * c;
}

// 🔗 Curried version - one parameter at a time
function curriedMultiply(a) {
  return function (b) {
    return function (c) {
      return a * b * c;
    };
  };
}

// 🚀 Modern arrow function version
const multiply = (a) => (b) => (c) => a * b * c;

// Usage examples
console.log(traditionalMultiply(2, 3, 4)); // 24

// Curried - step by step
const step1 = curriedMultiply(2); // Returns function waiting for 'b'
const step2 = step1(3); // Returns function waiting for 'c'
const result = step2(4); // Returns final result: 24

// Or chain it all together
console.log(curriedMultiply(2)(3)(4)); // 24
console.log(multiply(2)(3)(4)); // 24

// 🎯 The real power - create specialized functions
const double = multiply(2); // Multiply by 2
const triple = multiply(3); // Multiply by 3

const doubleAndSquare = double(4); // 2 * 4 * ?
const tripleAndSquare = triple(4); // 3 * 4 * ?

console.log(doubleAndSquare(5)); // 2 * 4 * 5 = 40
console.log(tripleAndSquare(5)); // 3 * 4 * 5 = 60
```

> **Explanation:**
>
> - Currying breaks a function into smaller functions, each taking one argument.
> - This lets you create specialized functions (like `double` or `triple`) easily.
> - It's like a sandwich shop where each station adds one ingredient at a time.

### 🎯 Practical Applications

```js
// 🌐 API Request Builder
const apiRequest = (method) => (url) => (data) => {
  return fetch(url, {
    method: method,
    headers: { "Content-Type": "application/json" },
    body: data ? JSON.stringify(data) : null,
  });
};

// Create specialized functions
const get = apiRequest("GET");
const post = apiRequest("POST");
const put = apiRequest("PUT");

// Use them
const getUsers = get("/api/users");
const createUser = post("/api/users");

getUsers(); // GET /api/users
createUser({ name: "John" }); // POST /api/users with data

// 💰 Discount Calculator
const discount = (percentage) => (price) => {
  return price - (price * percentage) / 100;
};

const tenPercentOff = discount(10);
const twentyPercentOff = discount(20);

console.log(tenPercentOff(100)); // 90
console.log(twentyPercentOff(100)); // 80
```

> **Explanation:**
>
> - Currying lets you build reusable, specialized functions for things like API requests or discounts.
> - You can create a `get` or `post` function once, then reuse it everywhere.
> - This is like having a sandwich shop where you can pre-make the bread or sauce for every order.

---

## 8. Memoization 🧠

### 📝 Simple Explanation

Remember the results of expensive calculations so you don't have to do them again.

### 🌍 Real-World Analogy

Like a **math student's cheat sheet**: Once you calculate 7 × 8 = 56, you write it down and never calculate it again.

### 💻 Basic Memoization

```js
// 🧠 Simple memoization function
function memoize(fn) {
  const cache = new Map();

  return function (...args) {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      console.log(`💾 Cache hit for ${key}`);
      return cache.get(key);
    }

    console.log(`⚡ Computing result for ${key}`);
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// 🔢 Expensive calculation example
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFibonacci = memoize(fibonacci);

console.log(memoizedFibonacci(10)); // ⚡ Computing... (takes time)
console.log(memoizedFibonacci(10)); // 💾 Cache hit! (instant)
console.log(memoizedFibonacci(15)); // ⚡ Computing... (but reuses cached values)
```

### 💻 Advanced Memoization with Expiry

```js
// 🕒 Memoization with expiration
function memoizeWithExpiry(fn, ttl = 60000) {
  // Default 1 minute
  const cache = new Map();

  return function (...args) {
    const key = JSON.stringify(args);
    const now = Date.now();

    if (cache.has(key)) {
      const { result, timestamp } = cache.get(key);

      if (now - timestamp < ttl) {
        console.log(`💾 Fresh cache hit for ${key}`);
        return result;
      } else {
        console.log(`🗑️ Cache expired for ${key}`);
        cache.delete(key);
      }
    }

    console.log(`⚡ Computing fresh result for ${key}`);
    const result = fn.apply(this, args);
    cache.set(key, { result, timestamp: now });
    return result;
  };
}

// 🌐 API call example
async function fetchUser(id) {
  console.log(`🌐 Making API call for user ${id}`);
  // Simulate API delay
  await new Promise((resolve) => setTimeout(resolve, 1000));
  return { id, name: `User ${id}`, email: `user${id}@example.com` };
}

const memoizedFetchUser = memoizeWithExpiry(fetchUser, 30000); // Cache for 30 seconds

// Usage
memoizedFetchUser(1).then(console.log); // 🌐 API call
memoizedFetchUser(1).then(console.log); // 💾 Cache hit
```

### 🎯 Perfect Use Cases

- **API responses** that don't change often
- **Complex calculations** (math, algorithms)
- **Database queries** with same parameters
- **Image processing** results
- **Search results** for recent queries

### 🏷️ Class Example

```js
// 🧠 Simple memoization function
function memoize(fn) {
  const cache = new Map();

  return function (...args) {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      console.log(`💾 Cache hit for ${key}`);
      return cache.get(key);
    }

    console.log(`⚡ Computing result for ${key}`);
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// 🔢 Expensive calculation example
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFibonacci = memoize(fibonacci);

console.log(memoizedFibonacci(10)); // ⚡ Computing... (takes time)
console.log(memoizedFibonacci(10)); // 💾 Cache hit! (instant)
console.log(memoizedFibonacci(15)); // ⚡ Computing... (but reuses cached values)
```

> **Explanation:**
>
> - The first time you call `memoizedFibonacci(10)`, it does all the work and stores the result.
> - The next time, it just grabs the answer from memory—no need to recalculate!
> - This is like a student writing down the answer to a hard math problem so they never have to solve it again.

### 💻 Advanced Memoization with Expiry

```js
// 🕒 Memoization with expiration
function memoizeWithExpiry(fn, ttl = 60000) {
  // Default 1 minute
  const cache = new Map();

  return function (...args) {
    const key = JSON.stringify(args);
    const now = Date.now();

    if (cache.has(key)) {
      const { result, timestamp } = cache.get(key);

      if (now - timestamp < ttl) {
        console.log(`💾 Fresh cache hit for ${key}`);
        return result;
      } else {
        console.log(`🗑️ Cache expired for ${key}`);
        cache.delete(key);
      }
    }

    console.log(`⚡ Computing fresh result for ${key}`);
    const result = fn.apply(this, args);
    cache.set(key, { result, timestamp: now });
    return result;
  };
}

// 🌐 API call example
async function fetchUser(id) {
  console.log(`🌐 Making API call for user ${id}`);
  // Simulate API delay
  await new Promise((resolve) => setTimeout(resolve, 1000));
  return { id, name: `User ${id}`, email: `user${id}@example.com` };
}

const memoizedFetchUser = memoizeWithExpiry(fetchUser, 30000); // Cache for 30 seconds

// Usage
memoizedFetchUser(1).then(console.log); // 🌐 API call
memoizedFetchUser(1).then(console.log); // 💾 Cache hit
```

> **Explanation:**
>
> - This version of memoization forgets old answers after a set time (like 30 seconds).
> - It's perfect for things like API calls where the data might change after a while.
> - This is like a grocery store that throws out old food after a day to keep things fresh!

### 🎯 Perfect Use Cases

- **API responses** that don't change often
- **Complex calculations** (math, algorithms)
- **Database queries** with same parameters
- **Image processing** results
- **Search results** for recent queries

## 🗂️ Pattern Comparison Guide

| Pattern              | Complexity | Use When                       | Avoid When                 |
| -------------------- | ---------- | ------------------------------ | -------------------------- |
| **Module**           | 🟢 Easy    | Need private variables         | Simple scripts             |
| **Revealing Module** | 🟢 Easy    | Want clear structure           | Very small modules         |
| **Singleton**        | 🟡 Medium  | Need ONE instance              | Need multiple instances    |
| **Factory**          | 🟡 Medium  | Creating similar objects       | Objects are very different |
| **Observer**         | 🟡 Medium  | Event systems                  | Simple notifications       |
| **Debounce**         | 🟢 Easy    | User input delays              | Need immediate response    |
| **Throttle**         | 🟢 Easy    | Limit frequency                | Need all events            |
| **Currying**         | 🔴 Hard    | Building specialized functions | Simple operations          |
| **Memoization**      | 🟡 Medium  | Expensive calculations         | Fast operations            |

---

## 🚀 Next Steps

### 📚 Practice Projects

1. **Todo App**: Use Module pattern for task management
2. **Theme Switcher**: Implement Singleton for app settings
3. **Form Validator**: Apply Factory pattern for different validators
4. **Real-time Chat**: Use Observer pattern for message updates
5. **Search App**: Combine Debounce with Memoization

### 🔗 Additional Resources

- [JavaScript Design Patterns - Addy Osmani](https://addyosmani.com/resources/essentialjsdesignpatterns/book/)
- [MDN Web Docs - JavaScript Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)
- [Patterns.dev - Modern Web App Patterns](https://patterns.dev/)
- [Refactoring.Guru - Design Patterns](https://refactoring.guru/design-patterns/javascript)

### 💬 Community

- Join JavaScript communities on Discord/Reddit
- Practice on coding platforms like LeetCode, Codewars
- Build projects and share on GitHub
- Write blog posts about what you learn

---

## 📋 Quick Reference Cheat Sheet

```js
// Module Pattern
const MyModule = (function () {
  let private = "secret";
  return { getPrivate: () => private };
})();

// Singleton Pattern
const Singleton = (function () {
  let instance;
  return { getInstance: () => instance || (instance = {}) };
})();

// Factory Pattern
const Factory = (type) => (type === "A" ? { a: 1 } : { b: 2 });

// Observer Pattern
class Subject {
  constructor() {
    this.observers = [];
  }
  notify(data) {
    this.observers.forEach((fn) => fn(data));
  }
}

// Debounce
const debounce = (fn, delay) => {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn(...args), delay);
  };
};

// Throttle
const throttle = (fn, limit) => {
  let inThrottle;
  return (...args) => {
    if (!inThrottle) {
      fn(...args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
};

// Currying
const curry = (a) => (b) => (c) => a + b + c;

// Memoization
const memoize = (fn) => {
  const cache = {};
  return (arg) => cache[arg] || (cache[arg] = fn(arg));
};
```

> **Explanation:**
>
> - This cheat sheet gives you a quick reference for each pattern.
> - Use it as a template for your own projects or interview prep!

---

**Happy coding! 🎉** Remember: The best pattern is the one that solves your specific problem clearly and simply.
