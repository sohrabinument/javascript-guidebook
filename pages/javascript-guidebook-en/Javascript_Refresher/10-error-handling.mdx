# JavaScript Error Handling üõ°Ô∏è

Imagine your JavaScript application as a space mission. Errors are like unexpected asteroids‚Äîyou can't prevent them all, but with proper error handling, you can navigate through them safely and keep your mission on track!

Welcome to the complete guide on JavaScript error handling, where you'll learn to transform crashes into graceful recoveries and frustrated users into happy customers.

---

## Why Error Handling is Your Superpower ü¶∏‚Äç‚ôÇÔ∏è

Error handling isn't just about preventing crashes‚Äîit's about creating professional, user-friendly applications that build trust and provide excellent user experiences.

### üöÄ **What Great Error Handling Gives You:**

**For Your Users:**

- Smooth, uninterrupted experiences
- Clear, helpful feedback when things go wrong
- Confidence in your application's reliability

**For Your Team:**

- Easier debugging with meaningful error messages
- Faster bug fixes with detailed error information
- Less time spent hunting mysterious crashes

**For Your Business:**

- Higher user retention and satisfaction
- Reduced support tickets and complaints
- Professional reputation and user trust

### The Cost of Poor Error Handling

```js
// ‚ùå This kills your app and frustrates users
function processPayment(amount) {
  const total = amount * tax; // ReferenceError: tax is not defined
  // App crashes, user loses their cart, trust is broken
}
```

> **Explanation:**
> This function tries to use a variable (`tax`) that hasn't been defined. When the code runs, JavaScript throws an error and stops the program. This can crash your app and frustrate users because their progress is lost.

```js
// ‚úÖ This keeps your app running and users happy
function processPayment(amount) {
  try {
    const tax = getTaxRate() || 0.08; // Fallback value
    const total = amount * (1 + tax);
    return total;
  } catch (error) {
    console.error("Payment processing error:", error);
    showUserFriendlyMessage(
      "We had trouble processing your payment. Please try again."
    );
    return null;
  }
}
```

> **Explanation:**
> This version uses a `try...catch` block. If something goes wrong (like `getTaxRate()` fails), the error is caught and handled. The user sees a friendly message instead of a crash, and the function returns `null` instead of breaking the whole app.

---

## Understanding JavaScript Errors: Know Your Enemy üéØ

Before you can handle errors effectively, you need to understand what you're dealing with. JavaScript errors come in different flavors, each requiring different strategies.

### 1. **Syntax Errors** - The Grammar Police üìù

These happen when JavaScript can't understand your code structure.

```js
// ‚ùå Syntax Error Examples
if (user.isActive {  // Missing closing parenthesis
  console.log('Active user');
}

const message = 'Hello World;  // Missing closing quote

function calculate(a, b,) {  // Trailing comma in older JS
  return a + b;
}
```

> **Explanation:**
> These are mistakes in how the code is written, like missing a parenthesis or quote, or using an extra comma. JavaScript can't even start running this code‚Äîit will show an error right away. Your code editor will usually highlight these errors.

### 2. **Runtime Errors** - The Sneaky Surprises üí•

These occur while your code is running, often due to unexpected conditions.

```js
// ‚ùå Runtime Error Examples
let user = null;
console.log(user.name); // TypeError: Cannot read property 'name' of null

let numbers = [1, 2, 3];
console.log(numbers[10].toString()); // TypeError: Cannot read property 'toString' of undefined

JSON.parse("invalid json"); // SyntaxError: Unexpected token in JSON
```

> **Explanation:**
> These errors happen while your code is running. For example, trying to use `.name` on `null`, or calling a method on something that doesn't exist. These errors can crash your app if not handled.

### 3. **Logical Errors** - The Silent Killers ü§´

These are the trickiest‚Äîyour code runs without crashing, but produces wrong results.

```js
// ‚ùå Logical Error Examples
function calculateDiscount(price, discountPercent) {
  // Bug: Should be price * (discountPercent / 100)
  return price * discountPercent; // 20% becomes 2000%!
}

function isAdult(age) {
  // Bug: Using assignment instead of comparison
  if ((age = 18)) {
    // Always true, assigns 18 to age
    return true;
  }
  return false;
}
```

> **Explanation:**
> These are mistakes in your logic. The first function multiplies instead of dividing, so discounts are way too big. The second function uses `=` (assignment) instead of `===` (comparison), so it always returns `true`.

---

## The Try-Catch-Finally Trinity üõ°Ô∏è

The foundation of JavaScript error handling is the `try...catch...finally` statement. Think of it as your error-handling safety net.

### Basic Try-Catch Structure

```js
try {
  // Code that might throw an error (the "risky zone")
  const result = performRiskyOperation();
  console.log("Success:", result);
} catch (error) {
  // Code that runs if an error occurs (the "safety net")
  console.error("Something went wrong:", error.message);
  handleError(error);
}
```

> **Explanation:**
> The `try` block runs code that might fail. If there's an error, the `catch` block runs instead of crashing the app. You can log the error and handle it gracefully.

### Real-World Example: API Call Handling

```js
async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const userData = await response.json();
    displayUserProfile(userData);
  } catch (error) {
    if (error.name === "TypeError") {
      // Network error
      showMessage("Network connection failed. Please check your internet.");
    } else if (error.message.includes("404")) {
      // User not found
      showMessage("User not found. Please check the user ID.");
    } else {
      // Generic error
      showMessage("Failed to load user data. Please try again later.");
    }

    console.error("User data fetch failed:", error);
  }
}
```

> **Explanation:**
> This function tries to get user data from a server. If the network is down, or the user doesn't exist, or something else goes wrong, it shows a helpful message. The app doesn't crash, and the user knows what happened.

### The Finally Block: Always Runs üèÅ

The `finally` block executes regardless of whether an error occurred‚Äîperfect for cleanup operations.

```js
function processFile(filename) {
  let fileHandle = null;

  try {
    fileHandle = openFile(filename);
    const data = readFile(fileHandle);
    return processData(data);
  } catch (error) {
    console.error("File processing failed:", error);
    return null;
  } finally {
    // This always runs, whether success or error
    if (fileHandle) {
      closeFile(fileHandle);
      console.log("File handle closed");
    }
  }
}
```

> **Explanation:**
> The `finally` block always runs, even if there was an error. It's used here to make sure the file is closed, so you don't leave files open by accident.

### Advanced Try-Catch Patterns

```js
// Nested try-catch for granular error handling
function complexOperation() {
  try {
    // Primary operation
    const step1 = performStep1();

    try {
      // Secondary operation that might fail differently
      const step2 = performStep2(step1);
      return step2;
    } catch (step2Error) {
      // Handle step2 failure specifically
      console.warn("Step 2 failed, using fallback:", step2Error.message);
      return getFallbackResult(step1);
    }
  } catch (primaryError) {
    // Handle primary operation failure
    console.error("Primary operation failed:", primaryError);
    throw new Error("Complex operation failed completely");
  }
}
```

> **Explanation:**
> This example shows nested `try...catch` blocks. If the secondary operation fails, you can handle it specifically and use a fallback. If the primary operation fails, you handle it at a higher level. This gives you more control over different types of errors.

---

## Creating and Throwing Custom Errors üéØ

Sometimes you need to create your own errors to provide better context and control over error handling.

### Basic Error Throwing

```js
function validateAge(age) {
  if (typeof age !== "number") {
    throw new TypeError("Age must be a number");
  }

  if (age < 0) {
    throw new Error("Age cannot be negative");
  }

  if (age > 150) {
    throw new Error("Age seems unrealistic");
  }

  return true;
}

// Usage
try {
  validateAge("25"); // Throws TypeError
} catch (error) {
  console.error("Validation failed:", error.message);
}
```

> **Explanation:**
> This function checks if the age is a number, not negative, and not too large. If any check fails, it throws an error with a helpful message. The `try...catch` block catches the error and logs it, so your app doesn't crash.

### Custom Error Classes for Better Organization

```js
// Base custom error class
class AppError extends Error {
  constructor(message, statusCode = 500) {
    super(message);
    this.name = this.constructor.name;
    this.statusCode = statusCode;
    this.isOperational = true; // Distinguishes from programming errors

    // Capture stack trace
    Error.captureStackTrace(this, this.constructor);
  }
}

// Specific error types
class ValidationError extends AppError {
  constructor(message, field = null) {
    super(message, 400);
    this.field = field;
  }
}

class NotFoundError extends AppError {
  constructor(resource = "Resource") {
    super(`${resource} not found`, 404);
  }
}

class AuthenticationError extends AppError {
  constructor(message = "Authentication required") {
    super(message, 401);
  }
}

class RateLimitError extends AppError {
  constructor(retryAfter = 60) {
    super("Rate limit exceeded", 429);
    this.retryAfter = retryAfter;
  }
}
```

> **Explanation:**
> These classes let you create different types of errors for different situations. For example, you can throw a `ValidationError` if user input is wrong, or a `NotFoundError` if something can't be found. This makes your error handling more organized and easier to manage.

### Using Custom Errors in Practice

```js
class UserService {
  static async createUser(userData) {
    try {
      // Validate input
      if (!userData.email) {
        throw new ValidationError("Email is required", "email");
      }

      if (!userData.email.includes("@")) {
        throw new ValidationError("Invalid email format", "email");
      }

      // Check if user exists
      const existingUser = await this.findByEmail(userData.email);
      if (existingUser) {
        throw new ValidationError("Email already registered", "email");
      }

      // Create user
      const user = await database.createUser(userData);
      return user;
    } catch (error) {
      // Re-throw custom errors as-is
      if (error instanceof AppError) {
        throw error;
      }

      // Wrap unexpected errors
      throw new AppError("Failed to create user: " + error.message);
    }
  }
}

// Usage with specific error handling
try {
  const newUser = await UserService.createUser({
    email: "invalid-email",
  });
} catch (error) {
  if (error instanceof ValidationError) {
    showFieldError(error.field, error.message);
  } else if (error instanceof AppError) {
    showGenericError(error.message);
  } else {
    showGenericError("An unexpected error occurred");
    console.error("Unexpected error:", error);
  }
}
```

> **Explanation:**
> This example shows how to use custom error classes in a real service. If something goes wrong (like a missing or invalid email), a specific error is thrown. When calling the function, you can handle each error type differently, giving users better feedback and making debugging easier.

---

## Async/Await Error Handling üîÑ

Modern JavaScript heavily uses async/await, which requires special attention to error handling.

### Basic Async Error Handling

```js
// ‚ùå Unhandled promise rejection
async function badExample() {
  const data = await fetchData(); // If this fails, error goes unhandled
  return data;
}

// ‚úÖ Proper async error handling
async function goodExample() {
  try {
    const data = await fetchData();
    return data;
  } catch (error) {
    console.error("Data fetch failed:", error);
    throw error; // Re-throw if needed, or return fallback
  }
}
```

> **Explanation:**
> The first function doesn't handle errors, so if `fetchData()` fails, the error is lost. The second function uses `try...catch` to handle errors, log them, and decide what to do next. This is the safer way to write async code.

### Advanced Async Patterns

```js
// Parallel operations with individual error handling
async function fetchMultipleResources() {
  const results = await Promise.allSettled([
    fetchUserData(),
    fetchPreferences(),
    fetchNotifications(),
  ]);

  const processedResults = results.map((result, index) => {
    if (result.status === "fulfilled") {
      return result.value;
    } else {
      console.error(`Operation ${index} failed:`, result.reason);
      return null; // or appropriate fallback
    }
  });

  return processedResults;
}
```

> **Explanation:**
> This function runs several async operations at once. It uses `Promise.allSettled` to wait for all of them, even if some fail. For each result, it checks if it succeeded or failed, logs any errors, and returns a fallback value if needed. This way, one failure doesn't stop the others.

```js
async function fetchWithRetry(url, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      return await response.json();
    } catch (error) {
      console.warn(`Attempt ${attempt} failed:`, error.message);

      if (attempt === maxRetries) {
        throw new Error(
          `Failed after ${maxRetries} attempts: ${error.message}`
        );
      }

      // Exponential backoff: wait 2^attempt seconds
      const delay = Math.pow(2, attempt) * 1000;
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
}
```

> **Explanation:**
> This function tries to fetch data from a URL, and if it fails, it retries up to a maximum number of times. Each retry waits longer than the last (exponential backoff). If all attempts fail, it throws an error. This is useful for handling flaky network requests.

### Async Error Boundaries

```js
// Global async error handler
process.on("unhandledRejection", (reason, promise) => {
  console.error("Unhandled Rejection at:", promise, "reason:", reason);
  // Log to error reporting service
  errorReporter.captureException(reason);
});

// Wrapper for safe async operations
function safeAsync(asyncFn) {
  return async (...args) => {
    try {
      return await asyncFn(...args);
    } catch (error) {
      console.error(`Error in ${asyncFn.name}:", error);
      // Handle or re-throw based on your needs
      throw error;
    }
  };
}

// Usage
const safeDataFetcher = safeAsync(async (id) => {
  const response = await fetch(`/api/data/${id}`);
  return response.json();
});
```

> **Explanation:**
> The first part sets up a global handler for unhandled promise rejections, so you don't miss any async errors. The `safeAsync` function wraps any async function so that errors are always caught and logged. This helps you avoid silent failures in async code.

---

## Error Handling Best Practices üèÜ

### 1. **Be Specific with Error Messages**

```js
// ‚ùå Vague and unhelpful
throw new Error("Something went wrong");

// ‚úÖ Specific and actionable
throw new Error("Failed to save user profile: email format is invalid");
```

> **Explanation:**
> Always use clear and specific error messages. This makes it much easier to understand what went wrong and how to fix it.

### 2. **Don't Swallow Errors Silently**

```js
// ‚ùå Silent failure - debugging nightmare
try {
  riskyOperation();
} catch (error) {
  // Nothing here - error disappears!
}

// ‚úÖ Log and handle appropriately
try {
  riskyOperation();
} catch (error) {
  console.error("Risky operation failed:", error);
  notifyErrorReportingService(error);
  showUserFriendlyMessage("Operation failed. Please try again.");
}
```

> **Explanation:**
> If you catch an error but do nothing, it disappears and is hard to debug. Always log errors and show a helpful message to the user.

### 3. **Validate Early and Often**

```js
function processPayment(paymentData) {
  // Validate at the start
  if (!paymentData) {
    throw new ValidationError("Payment data is required");
  }

  if (!paymentData.amount || paymentData.amount <= 0) {
    throw new ValidationError("Payment amount must be positive");
  }

  if (!paymentData.method) {
    throw new ValidationError("Payment method is required");
  }

  // Now proceed with confidence
  return actuallyProcessPayment(paymentData);
}
```

> **Explanation:**
> Check your inputs at the start of a function. If something is missing or invalid, throw an error right away. This prevents bugs and makes your code safer.

### 4. **Use Error Boundaries in Complex Applications**

```js
class ErrorBoundary {
  constructor() {
    this.errors = [];
  }

  wrap(fn) {
    return (...args) => {
      try {
        return fn(...args);
      } catch (error) {
        this.handleError(error);
        throw error;
      }
    };
  }

  handleError(error) {
    this.errors.push({
      error,
      timestamp: new Date(),
      context: this.getContext(),
    });

    // Report to monitoring service
    this.reportError(error);
  }

  getContext() {
    return {
      url: window.location?.href,
      userAgent: navigator?.userAgent,
      userId: getCurrentUserId(),
    };
  }
}
```

> **Explanation:**
> This class helps you catch and handle errors in complex apps. You can wrap functions with it, and if they throw errors, those errors are logged and reported. This is useful for tracking and fixing bugs in big projects.

#### üõ†Ô∏è Practical Example: React Error Boundary

If you're building a React app, you can use an Error Boundary component to catch errors in your UI and prevent the whole app from crashing.

```jsx
import React from "react";

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render shows the fallback UI
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // You can log the error to an error reporting service here
    console.error("Error caught by ErrorBoundary:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // Fallback UI when an error occurs
      return (
        <div style={{ color: "red" }}>
          <h2>Something went wrong.</h2>
          <p>{this.state.error && this.state.error.toString()}</p>
        </div>
      );
    }
    // Render children if no error
    return this.props.children;
  }
}

export default ErrorBoundary;
```

**How to use it:**

```jsx
import ErrorBoundary from "./ErrorBoundary";
import MyComponent from "./MyComponent";

function App() {
  return (
    <ErrorBoundary>
      <MyComponent />
    </ErrorBoundary>
  );
}
```

> **Explanation:**
>
> - The `ErrorBoundary` component catches errors in any child component and displays a fallback UI instead of crashing the whole app.
> - You can use it to wrap any part of your UI that might throw errors, making your app more robust and user-friendly.
> - This is especially useful in large applications where you want to isolate errors to specific sections of your UI.

### 5. **Implement Circuit Breaker Pattern**

```js
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.threshold = threshold;
    this.timeout = timeout;
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.state = "CLOSED"; // CLOSED, OPEN, HALF_OPEN
  }

  async call(fn) {
    if (this.state === "OPEN") {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = "HALF_OPEN";
      } else {
        throw new Error("Circuit breaker is OPEN");
      }
    }

    try {
      const result = await fn();
      this.reset();
      return result;
    } catch (error) {
      this.recordFailure();
      throw error;
    }
  }

  recordFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();

    if (this.failureCount >= this.threshold) {
      this.state = "OPEN";
    }
  }

  reset() {
    this.failureCount = 0;
    this.state = "CLOSED";
  }
}
```

> **Explanation:**
> This class is used to prevent your app from repeatedly trying something that's failing (like calling a broken API). If there are too many failures, it "opens the circuit" and stops trying for a while. This protects your app and the server from overload.

#### üõ†Ô∏è Practical Example: Using a Circuit Breaker for API Calls

Suppose you have a function that fetches data from an external API, but sometimes the API is down. You can use the CircuitBreaker to avoid overwhelming the API and to fail fast in your app:

```js
// Create a circuit breaker instance
const apiBreaker = new CircuitBreaker(3, 30000); // 3 failures, 30 seconds timeout

async function fetchUserProfile(userId) {
  return apiBreaker.call(async () => {
    const response = await fetch(`https://api.example.com/users/${userId}`);
    if (!response.ok) {
      throw new Error(`API error: ${response.status}`);
    }
    return response.json();
  });
}

// Usage
async function showProfile(userId) {
  try {
    const profile = await fetchUserProfile(userId);
    displayProfile(profile);
  } catch (error) {
    if (error.message.includes("Circuit breaker is OPEN")) {
      showMessage(
        "Service is temporarily unavailable. Please try again later."
      );
    } else {
      showMessage("Failed to load profile.");
    }
    console.error(error);
  }
}
```

> **Explanation:**
>
> - The `apiBreaker` will allow up to 3 failures before "opening the circuit" and blocking further calls for 30 seconds.
> - If the API keeps failing, your app will stop making requests for a while, reducing load and giving the service time to recover.
> - When the circuit is open, users see a friendly message instead of waiting for repeated failures.
> - This pattern is especially useful for protecting your app from unreliable external services.

---

## Real-World Error Handling Scenarios üåç

### Scenario 1: E-commerce Checkout Process

```js
class CheckoutProcessor {
  async processCheckout(cartData, paymentInfo, shippingInfo) {
    const checkoutId = generateCheckoutId();

    try {
      // Step 1: Validate cart
      await this.validateCart(cartData);

      // Step 2: Check inventory
      await this.checkInventory(cartData.items);

      // Step 3: Process payment
      const paymentResult = await this.processPayment(paymentInfo);

      // Step 4: Create order
      const order = await this.createOrder({
        cartData,
        paymentResult,
        shippingInfo,
        checkoutId,
      });

      // Step 5: Send confirmation
      await this.sendOrderConfirmation(order);

      return {
        success: true,
        orderId: order.id,
        message: "Order placed successfully!",
      };
    } catch (error) {
      // Log error with context
      console.error("Checkout failed:", {
        checkoutId,
        error: error.message,
        stack: error.stack,
        userId: paymentInfo.userId,
      });

      // Handle specific error types
      if (error instanceof ValidationError) {
        return {
          success: false,
          error: "VALIDATION_ERROR",
          message: error.message,
          field: error.field,
        };
      }

      if (error instanceof InventoryError) {
        return {
          success: false,
          error: "INVENTORY_ERROR",
          message: "Some items are no longer available",
          unavailableItems: error.items,
        };
      }

      if (error instanceof PaymentError) {
        return {
          success: false,
          error: "PAYMENT_ERROR",
          message: "Payment processing failed",
          paymentErrorCode: error.code,
        };
      }

      // Generic error response
      return {
        success: false,
        error: "CHECKOUT_ERROR",
        message:
          "We encountered an issue processing your order. Please try again.",
        supportId: checkoutId,
      };
    }
  }
}
```

> **Explanation:**
> This class handles the checkout process for an online store. Each step (validation, inventory check, payment, order creation, confirmation) can fail, so everything is wrapped in a try-catch. If something goes wrong, it logs the error and returns a specific error message depending on what failed. This helps users and developers know exactly what went wrong.

### Scenario 2: File Upload with Progress Tracking

```js
class FileUploader {
  async uploadFile(file, options = {}) {
    const uploadId = generateUploadId();

    try {
      // Validate file
      this.validateFile(file);

      // Create progress tracker
      const progressTracker = new ProgressTracker(uploadId);

      // Upload with retry logic
      const result = await this.uploadWithRetry(file, {
        ...options,
        onProgress: (progress) => {
          progressTracker.update(progress);
          options.onProgress?.(progress);
        },
      });

      progressTracker.complete();
      return result;
    } catch (error) {
      // Clean up on error
      await this.cleanupFailedUpload(uploadId);

      if (error instanceof FileSizeError) {
        throw new Error(`File too large. Maximum size is ${error.maxSize}MB`);
      }

      if (error instanceof FileTypeError) {
        throw new Error(
          `File type not supported. Allowed types: ${error.allowedTypes.join(
            ", "
          )}`
        );
      }

      if (error instanceof NetworkError) {
        throw new Error(
          "Upload failed due to network issues. Please check your connection and try again."
        );
      }

      // Generic upload error
      throw new Error(
        "Upload failed. Please try again or contact support if the problem persists."
      );
    }
  }

  validateFile(file) {
    if (!file) {
      throw new ValidationError("No file provided");
    }

    if (file.size > MAX_FILE_SIZE) {
      throw new FileSizeError(file.size, MAX_FILE_SIZE);
    }

    if (!ALLOWED_TYPES.includes(file.type)) {
      throw new FileTypeError(file.type, ALLOWED_TYPES);
    }
  }
}
```

> **Explanation:**
> This class manages file uploads. It checks if the file is valid, tracks upload progress, and handles errors like file size, type, or network issues. If something goes wrong, it cleans up and throws a helpful error message. This makes file uploads more reliable and user-friendly.

---

## Debugging and Monitoring üîç

### Error Logging Strategies

```js
class ErrorLogger {
  static log(error, context = {}) {
    const errorInfo = {
      message: error.message,
      stack: error.stack,
      name: error.name,
      timestamp: new Date().toISOString(),
      url: window.location?.href,
      userAgent: navigator?.userAgent,
      userId: this.getCurrentUserId(),
      ...context,
    };

    // Log to console (development)
    if (process.env.NODE_ENV === "development") {
      console.error("Error logged:", errorInfo);
    }

    // Send to monitoring service (production)
    if (process.env.NODE_ENV === "production") {
      this.sendToMonitoringService(errorInfo);
    }

    // Store locally for offline support
    this.storeLocalError(errorInfo);
  }

  static sendToMonitoringService(errorInfo) {
    // Integration with services like Sentry, LogRocket, etc.
    try {
      fetch("/api/errors", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(errorInfo),
      }).catch((err) => {
        console.warn("Failed to send error to monitoring service:", err);
      });
    } catch (err) {
      console.warn("Error logging failed:", err);
    }
  }
}

// Global error handlers
window.addEventListener("error", (event) => {
  ErrorLogger.log(event.error, {
    type: "global_error",
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno,
  });
});

window.addEventListener("unhandledrejection", (event) => {
  ErrorLogger.log(event.reason, {
    type: "unhandled_promise_rejection",
  });
});
```

> **Explanation:**
> This code logs errors in your app. It collects details about the error and the user's environment, logs them to the console in development, and sends them to a monitoring service in production. It also sets up global handlers to catch any errors that aren't handled elsewhere, so you never miss a bug.

### Error Reporting Dashboard

```js
class ErrorReporter {
  constructor() {
    this.errors = [];
    this.filters = {
      severity: "all",
      timeRange: "24h",
      userId: null,
    };
  }

  reportError(error, severity = "medium") {
    const errorReport = {
      id: generateId(),
      error,
      severity,
      timestamp: Date.now(),
      resolved: false,
      occurrences: 1,
    };

    // Check for duplicate errors
    const existing = this.findSimilarError(error);
    if (existing) {
      existing.occurrences++;
      existing.lastOccurrence = Date.now();
    } else {
      this.errors.push(errorReport);
    }

    // Auto-escalate frequent errors
    if (existing && existing.occurrences > 10) {
      this.escalateError(existing);
    }
  }

  generateErrorSummary() {
    return {
      totalErrors: this.errors.length,
      criticalErrors: this.errors.filter((e) => e.severity === "critical")
        .length,
      mostFrequent: this.getMostFrequentErrors(5),
      recentTrends: this.getErrorTrends(),
    };
  }
}
```

> **Explanation:**
> This class helps you collect, filter, and summarize errors in your app. It can track how often errors happen, escalate frequent issues, and generate reports. This is useful for monitoring the health of your application over time.

---

## Testing Error Handling üß™

### Unit Testing Error Scenarios

```js
// Using Jest for error testing
describe("UserService", () => {
  describe("createUser", () => {
    it("should throw ValidationError for missing email", async () => {
      await expect(UserService.createUser({})).rejects.toThrow(ValidationError);
    });

    it("should throw ValidationError with correct message for invalid email", async () => {
      await expect(
        UserService.createUser({ email: "invalid" })
      ).rejects.toThrow("Invalid email format");
    });

    it("should handle database errors gracefully", async () => {
      // Mock database to throw error
      jest
        .spyOn(database, "createUser")
        .mockRejectedValue(new Error("DB Error"));

      await expect(
        UserService.createUser({ email: "test@example.com" })
      ).rejects.toThrow("Failed to create user");
    });
  });
});

// Testing async error handling
describe("AsyncOperations", () => {
  it("should handle network failures", async () => {
    // Mock fetch to fail
    global.fetch = jest.fn().mockRejectedValue(new Error("Network Error"));

    const result = await fetchUserData("123");
    expect(result).toBeNull();
    expect(console.error).toHaveBeenCalledWith(
      expect.stringContaining("Network Error")
    );
  });
});
```

> **Explanation:**
> These are unit tests for error handling. They check that your code throws the right errors when something goes wrong, like missing data or a failed network request. This helps you make sure your error handling works as expected.

### Integration Testing

```js
// Testing complete error flows
describe("Checkout Process", () => {
  it("should handle payment failures gracefully", async () => {
    // Setup: Mock payment service to fail
    paymentService.processPayment.mockRejectedValue(
      new PaymentError("Card declined", "CARD_DECLINED")
    );

    const result = await checkoutProcessor.processCheckout(
      mockCart,
      mockPayment,
      mockShipping
    );

    expect(result.success).toBe(false);
    expect(result.error).toBe("PAYMENT_ERROR");
    expect(result.message).toContain("Payment processing failed");
  });
});
```

> **Explanation:**
> This is an integration test for the checkout process. It simulates a payment failure and checks that your code returns the correct error message. This ensures your app handles real-world problems smoothly.

---

## Performance Considerations ‚ö°

### Optimizing Error Handling

```js
// ‚ùå Heavy error handling that impacts performance
try {
  for (let i = 0; i < 1000000; i++) {
    try {
      processItem(items[i]);
    } catch (error) {
      logError(error); // Called potentially millions of times
    }
  }
} catch (error) {
  handleGlobalError(error);
}

// ‚úÖ Optimized error handling
const errors = [];
try {
  for (let i = 0; i < 1000000; i++) {
    try {
      processItem(items[i]);
    } catch (error) {
      errors.push({ index: i, error }); // Batch errors
    }
  }
} catch (error) {
  handleGlobalError(error);
} finally {
  if (errors.length > 0) {
    logBatchErrors(errors); // Single logging operation
  }
}
```

> **Explanation:**
> The first example logs every error as it happens, which can slow down your app if there are many errors. The second example collects errors in a list and logs them all at once, which is much more efficient for large operations.

### Memory Management

```js
class ErrorBuffer {
  constructor(maxSize = 100) {
    this.errors = [];
    this.maxSize = maxSize;
  }

  addError(error) {
    this.errors.push({
      error,
      timestamp: Date.now(),
    });

    // Prevent memory leaks
    if (this.errors.length > this.maxSize) {
      this.errors.shift(); // Remove oldest error
    }
  }

  getRecentErrors(count = 10) {
    return this.errors.slice(-count);
  }

  clear() {
    this.errors.length = 0;
  }
}
```

> **Explanation:**
> This class stores recent errors in memory, but only up to a certain limit. If too many errors are added, it removes the oldest ones. This prevents your app from using too much memory if there are lots of errors.

---

## Framework-Specific Error Handling üîß

### React Error Boundaries

```js
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error("React Error Boundary caught an error:", error, errorInfo);

    // Log to error reporting service
    ErrorLogger.log(error, {
      type: "react_error_boundary",
      componentStack: errorInfo.componentStack,
    });
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-fallback">
          <h2>Something went wrong</h2>
          <p>We're sorry, but something unexpected happened.</p>
          <button onClick={() => window.location.reload()}>Refresh Page</button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

> **Explanation:**
> This is a React component that catches errors in its child components. If an error happens, it shows a fallback UI and logs the error. This prevents the whole app from crashing and gives users a better experience.

### Node.js Error Handling

```js
// Global error handlers for Node.js
process.on("uncaughtException", (error) => {
  console.error("Uncaught Exception:", error);
  ErrorLogger.log(error, { type: "uncaught_exception" });

  // Graceful shutdown
  process.exit(1);
});

process.on("unhandledRejection", (reason, promise) => {
  console.error("Unhandled Rejection at:", promise, "reason:", reason);
  ErrorLogger.log(reason, { type: "unhandled_rejection" });
});

// Express.js error middleware
app.use((error, req, res, next) => {
  ErrorLogger.log(error, {
    type: "express_error",
    method: req.method,
    url: req.url,
    userAgent: req.get("User-Agent"),
  });

  if (error instanceof ValidationError) {
    return res.status(400).json({
      error: "Validation Error",
      message: error.message,
      field: error.field,
    });
  }

  if (error instanceof AuthenticationError) {
    return res.status(401).json({
      error: "Authentication Required",
      message: error.message,
    });
  }

  // Generic error response
  res.status(500).json({
    error: "Internal Server Error",
    message: "Something went wrong on our end",
  });
});
```

> **Explanation:**
> This code shows how to handle errors in a Node.js server. It sets up global handlers for uncaught exceptions and unhandled promise rejections, and provides middleware for handling errors in Express.js. This ensures that errors are logged and users get helpful error messages instead of a server crash.

---

## Next Steps: Mastering Error Handling üöÄ

### Advanced Topics to Explore

1. **Error Monitoring and Alerting**

   - Integrate with Sentry, LogRocket, or Bugsnag
   - Set up automated alerts for critical errors
   - Create error dashboards and reports

2. **Distributed System Error Handling**

   - Circuit breaker patterns
   - Bulkhead isolation
   - Timeout and retry strategies

3. **Security Considerations**
   - Preventing information leakage in error messages
   - Rate limiting error endpoints
   - Error-based attack prevention

### Practice Projects

1. **Build a Robust API Client**

   - Implement retry logic with exponential backoff
   - Handle network failures gracefully
   - Provide meaningful error feedback

2. **Create an Error Monitoring Dashboard**

   - Collect and categorize errors
   - Show error trends and patterns
   - Implement alerting for critical issues

3. **Develop a Form Validation System**
   - Real-time validation with error handling
   - User-friendly error messages
   - Progressive enhancement for accessibility

---

## Resources for Continued Learning üìö

### Documentation and Guides

- [MDN: Error Handling](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling) - Comprehensive official documentation
- [JavaScript.info: Error Handling](https://javascript.info/try-catch) - Excellent tutorials with interactive examples
- [Node.js Error Handling Best Practices](https://nodejs.org/en/docs/guides/error-handling
