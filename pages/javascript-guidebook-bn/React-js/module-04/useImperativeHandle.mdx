---
title: "React ржП useImperativeHandle ЁЯЪА"
---

import { Callout } from "nextra/components";

# useImperativeHandle: ржХрж╛рж╕рзНржЯржо ржХржорзНржкрзЛржирзЗржирзНржЯ API рждрзИрж░рж┐ ржХрж░рж╛ ЁЯЫая╕ПтЬи

`useImperativeHandle` рж╣рж▓рзЛ ржПржХржЯрж┐ рж╢ржХрзНрждрж┐рж╢рж╛рж▓рзА React Hook ржпрж╛ ржЖржкржирж╛ржХрзЗ `forwardRef` ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛рж░ рж╕ржоржпрж╝ parent components ржПрж░ ржХрж╛ржЫрзЗ exposed interface ржХрж╛рж╕рзНржЯржорж╛ржЗржЬ ржХрж░рждрзЗ ржжрзЗржпрж╝ред ржПржЯрж┐ржХрзЗ ржЖржкржирж╛рж░ ржХржорзНржкрзЛржирзЗржирзНржЯрзЗрж░ ржЬржирзНржп ржПржХржЯрж┐ "рж░рж┐ржорзЛржЯ ржХржирзНржЯрзНрж░рзЛрж▓" ЁЯОо рждрзИрж░рж┐ ржХрж░рж╛рж░ ржорждрзЛ ржнрж╛ржмрзБржи - ржЖржкржирж┐ ржарж┐ржХ ржХрж░рзЗржи parent ржХрзЛржи ржмрж╛ржЯржиржЧрзБрж▓рзЛ ржЪрж╛ржкрждрзЗ ржкрж╛рж░ржмрзЗ!

---

## useImperativeHandle ржХрзЗ ржмрж┐рж╢рзЗрж╖ ржХрж░рзЗ рждрзЛрж▓рзЗ ржХрж┐? ЁЯМЯ

ржХрж▓рзНржкржирж╛ ржХрж░рзБржи ржЖржкржирж┐ ржПржХржЯрж┐ рж╕рзНржорж╛рж░рзНржЯ ржЯрж┐ржнрж┐ ЁЯУ║ рждрзИрж░рж┐ ржХрж░ржЫрзЗржиред ржЖржкржирж┐ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАржжрзЗрж░ рж╕ржм internal circuits ржПрж░ access ржжрж┐рждрзЗ ржЪрж╛ржи ржирж╛ - ржЖржкржирж┐ рждрж╛ржжрзЗрж░ ржПржХржЯрж┐ рж░рж┐ржорзЛржЯ ржжрзЗржи ржпрж╛рждрзЗ рж╢рзБржзрзБржорж╛рждрзНрж░ ржкрзНрж░ржпрж╝рзЛржЬржирзАржпрж╝ ржмрж╛ржЯржиржЧрзБрж▓рзЛ ржЖржЫрзЗ: power, volume, channelред `useImperativeHandle` ржЖржкржирж╛рж░ components ржПрж░ ржЬржирзНржп ржарж┐ржХ ржПржЯрж╛ржЗ ржХрж░рзЗ!

<Callout type="info" emoji="ЁЯОп">
**ржкрж╛рж░ржлрзЗржХрзНржЯ ржПрж░ ржЬржирзНржп:** 
- ржХрж╛рж╕рзНржЯржо API рждрзИрж░рж┐ ржХрж░рж╛ ржпрж╛ implementation details рж▓рзБржХрж┐ржпрж╝рзЗ рж░рж╛ржЦрзЗ ЁЯФТ 
- parent components ржПрж░ ржХрж╛ржЫрзЗ рж╢рзБржзрзБржорж╛рждрзНрж░ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ methods expose ржХрж░рж╛ ЁЯОк
- clean interfaces рж╕рж╣ reusable component libraries рждрзИрж░рж┐ ржХрж░рж╛ ЁЯУЪ 
- third-party libraries ржПрж░ рж╕рж╛ржерзЗ ржирж┐рж░рж╛ржкржжрзЗ integrate ржХрж░рж╛ ЁЯдЭ
</Callout>

---

## useImperativeHandle ржпрзЗ рж╕ржорж╕рзНржпрж╛рж░ рж╕ржорж╛ржзрж╛ржи ржХрж░рзЗ ЁЯдФ

`useImperativeHandle` ржЫрж╛ржбрж╝рж╛, `forwardRef` ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж▓рзЗ parents рж╕ржорзНржкрзВрж░рзНржг DOM node ржПрж░ access ржкрж╛ржпрж╝:

```jsx
// тЭМ Parent ржкрзВрж░рзНржг DOM access ржкрж╛ржпрж╝ - рж╕ржмрж╕ржоржпрж╝ ржПржЯрж╛ ржЖржорж░рж╛ ржЪрж╛ржЗ ржирж╛
const Input = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});

function Parent() {
  const inputRef = useRef(null);

  const handleClick = () => {
    // Parent DOM node ржПрж░ рж╕рж╛ржерзЗ ржпрзЗржХрзЛржирзЛ ржХрж┐ржЫрзБ ржХрж░рждрзЗ ржкрж╛рж░рзЗ
    inputRef.current.style.backgroundColor = "red"; // ЁЯШ▒
    inputRef.current.remove(); // ЁЯТе ржмрж┐ржкржЬрзНржЬржиржХ!
    inputRef.current.focus(); // тЬЕ ржПржЯрж╛ржЗ ржЖржорж░рж╛ ржЖрж╕рж▓рзЗ ржЪрж╛ржЗ
  };
}
```

---

## рж╕ржорж╛ржзрж╛ржи: ржирж┐ржпрж╝ржирзНрждрзНрж░рж┐ржд Access ЁЯФР

```jsx
// тЬЕ Parent рж╢рзБржзрзБржорж╛рждрзНрж░ ржЖржорж░рж╛ ржпрж╛ explicitly expose ржХрж░рж┐ рждрж╛ржЗ ржкрж╛ржпрж╝
const SmartInput = forwardRef((props, ref) => {
  const inputRef = useRef(null);

  useImperativeHandle(ref, () => ({
    // рж╢рзБржзрзБржорж╛рждрзНрж░ ржирж┐рж░рж╛ржкржж, ржЙржжрзНржжрзЗрж╢рзНржпржкрзНрж░ржгрзЛржжрж┐ржд methods expose ржХрж░рзБржи
    focus: () => inputRef.current?.focus(),
    clear: () => {
      inputRef.current.value = "";
    },
    getValue: () => inputRef.current?.value || "",
  }));

  return <input ref={inputRef} {...props} />;
});
```

---

## ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ Implementation ржЧрж╛ржЗржб ЁЯУЛ

### ржзрж╛ржк рзз: Component Structure рж╕рзЗржЯ ржЖржк ржХрж░рзБржи

```jsx
import React, { useRef, useImperativeHandle, forwardRef } from "react";

const MyComponent = forwardRef((props, ref) => {
  // ржкрзНрж░ржХрзГржд DOM element ржПрж░ ржЬржирзНржп internal ref рждрзИрж░рж┐ ржХрж░рзБржи
  const internalRef = useRef(null);

  // ржЖржкржирж╛рж░ component JSX ржПржЦрж╛ржирзЗ
  return <div ref={internalRef}>Content</div>;
});
```

### ржзрж╛ржк рзи: ржЖржкржирж╛рж░ Custom API Define ржХрж░рзБржи

```jsx
const MyComponent = forwardRef((props, ref) => {
  const internalRef = useRef(null);

  // parent ржХрж┐ access ржХрж░рждрзЗ ржкрж╛рж░ржмрзЗ рждрж╛ define ржХрж░рзБржи
  useImperativeHandle(ref, () => ({
    // Method 1: рж╕рж╣ржЬ action
    highlight: () => {
      internalRef.current.style.backgroundColor = "yellow";
    },

    // Method 2: data return ржХрж░рж╛
    getHeight: () => {
      return internalRef.current.offsetHeight;
    },

    // Method 3: parameters ржЧрзНрж░рж╣ржг ржХрж░рж╛
    scrollTo: (position) => {
      internalRef.current.scrollTop = position;
    },
  }));

  return <div ref={internalRef}>My Component</div>;
});
```

### ржзрж╛ржк рзй: Parent Component ржП ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи

```jsx
function Parent() {
  const myComponentRef = useRef(null);

  return (
    <div>
      <MyComponent ref={myComponentRef} />

      <button onClick={() => myComponentRef.current?.highlight()}>
        Highlight ЁЯОи
      </button>

      <button
        onClick={() => {
          const height = myComponentRef.current?.getHeight();
          alert(`Height: ${height}px`);
        }}
      >
        Get Height ЁЯУП
      </button>

      <button onClick={() => myComponentRef.current?.scrollTo(100)}>
        Scroll Down ЁЯУЬ
      </button>
    </div>
  );
}
```

---

## ржмрж╛рж╕рзНрждржм ржЬрзАржмржирзЗрж░ ржЙржжрж╛рж╣рж░ржг ЁЯМН

### рзз. Advanced Input Component ЁЯУЭ

```jsx
const AdvancedInput = forwardRef(({ onValueChange, ...props }, ref) => {
  const inputRef = useRef(null);
  const [history, setHistory] = useState([]);

  useImperativeHandle(ref, () => ({
    // ржорзМрж▓рж┐ржХ controls
    focus: () => inputRef.current?.focus(),
    blur: () => inputRef.current?.blur(),
    clear: () => {
      inputRef.current.value = "";
      onValueChange?.("");
    },

    // ржЙржирзНржиржд features
    selectAll: () => inputRef.current?.select(),

    setValue: (value) => {
      inputRef.current.value = value;
      setHistory((prev) => [...prev, value]);
      onValueChange?.(value);
    },

    // Utility methods
    getValue: () => inputRef.current?.value || "",
    getHistory: () => [...history],

    // Animation methods
    shake: () => {
      inputRef.current.style.animation = "shake 0.5s";
      setTimeout(() => {
        inputRef.current.style.animation = "";
      }, 500);
    },
  }));

  return (
    <div className="advanced-input-wrapper">
      <input
        ref={inputRef}
        onChange={(e) => {
          setHistory((prev) => [...prev, e.target.value]);
          onValueChange?.(e.target.value);
        }}
        {...props}
      />
      <style jsx>{`
        @keyframes shake {
          0%,
          100% {
            transform: translateX(0);
          }
          25% {
            transform: translateX(-5px);
          }
          75% {
            transform: translateX(5px);
          }
        }
      `}</style>
    </div>
  );
});

// ржмрзНржпржмрж╣рж╛рж░
function Form() {
  const nameInputRef = useRef(null);
  const emailInputRef = useRef(null);

  const validateForm = () => {
    const name = nameInputRef.current?.getValue();
    const email = emailInputRef.current?.getValue();

    if (!name) {
      nameInputRef.current?.focus();
      nameInputRef.current?.shake();
      return false;
    }

    if (!email?.includes("@")) {
      emailInputRef.current?.focus();
      emailInputRef.current?.shake();
      return false;
    }

    return true;
  };

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        if (validateForm()) {
          alert("Form is valid! ЁЯОЙ");
        }
      }}
    >
      <AdvancedInput
        ref={nameInputRef}
        placeholder="ржЖржкржирж╛рж░ ржирж╛ржо рж▓рж┐ржЦрзБржи ЁЯСд"
        onValueChange={(value) => console.log("Name:", value)}
      />

      <AdvancedInput
        ref={emailInputRef}
        type="email"
        placeholder="ржЖржкржирж╛рж░ ржЗржорзЗржЗрж▓ рж▓рж┐ржЦрзБржи ЁЯУз"
        onValueChange={(value) => console.log("Email:", value)}
      />

      <div className="form-actions">
        <button type="submit">Submit ЁЯЪА</button>
        <button
          type="button"
          onClick={() => {
            nameInputRef.current?.clear();
            emailInputRef.current?.clear();
          }}
        >
          рж╕ржм Clear ржХрж░рзБржи ЁЯз╣
        </button>
        <button
          type="button"
          onClick={() => {
            console.log("Name history:", nameInputRef.current?.getHistory());
            console.log("Email history:", emailInputRef.current?.getHistory());
          }}
        >
          History ржжрзЗржЦрж╛ржи ЁЯУК
        </button>
      </div>
    </form>
  );
}
```

### рзи. Media Player Component ЁЯО╡

```jsx
const MediaPlayer = forwardRef(({ src, ...props }, ref) => {
  const videoRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);

  useImperativeHandle(ref, () => ({
    // Playback controls
    play: async () => {
      try {
        await videoRef.current?.play();
        setIsPlaying(true);
      } catch (error) {
        console.error("Play ржХрж░рждрзЗ ржмрзНржпрж░рзНрже:", error);
      }
    },

    pause: () => {
      videoRef.current?.pause();
      setIsPlaying(false);
    },

    toggle: () => {
      if (isPlaying) {
        ref.current.pause();
      } else {
        ref.current.play();
      }
    },

    // Seeking
    seekTo: (time) => {
      if (videoRef.current) {
        videoRef.current.currentTime = time;
        setCurrentTime(time);
      }
    },

    skipForward: (seconds = 10) => {
      const current = videoRef.current?.currentTime || 0;
      ref.current.seekTo(current + seconds);
    },

    skipBackward: (seconds = 10) => {
      const current = videoRef.current?.currentTime || 0;
      ref.current.seekTo(Math.max(0, current - seconds));
    },

    // Volume control
    setVolume: (volume) => {
      if (videoRef.current) {
        videoRef.current.volume = Math.max(0, Math.min(1, volume));
      }
    },

    mute: () => {
      if (videoRef.current) {
        videoRef.current.muted = true;
      }
    },

    unmute: () => {
      if (videoRef.current) {
        videoRef.current.muted = false;
      }
    },

    // Information getters
    getDuration: () => videoRef.current?.duration || 0,
    getCurrentTime: () => videoRef.current?.currentTime || 0,
    getVolume: () => videoRef.current?.volume || 1,
    isPlaying: () => isPlaying,

    // ржЙржирзНржиржд features
    takeScreenshot: () => {
      const canvas = document.createElement("canvas");
      const video = videoRef.current;
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(video, 0, 0);
      return canvas.toDataURL();
    },
  }));

  return (
    <video
      ref={videoRef}
      src={src}
      onTimeUpdate={(e) => setCurrentTime(e.target.currentTime)}
      onPlay={() => setIsPlaying(true)}
      onPause={() => setIsPlaying(false)}
      {...props}
    />
  );
});

// ржмрзНржпржмрж╣рж╛рж░
function VideoApp() {
  const playerRef = useRef(null);

  return (
    <div className="video-app">
      <MediaPlayer
        ref={playerRef}
        src="/sample-video.mp4"
        controls={false}
        width="100%"
      />

      <div className="custom-controls">
        <button onClick={() => playerRef.current?.play()}>тЦ╢я╕П Play</button>
        <button onClick={() => playerRef.current?.pause()}>тП╕я╕П Pause</button>
        <button onClick={() => playerRef.current?.skipBackward()}>
          тПк -10s
        </button>
        <button onClick={() => playerRef.current?.skipForward()}>
          тПй +10s
        </button>

        <button
          onClick={() => {
            const screenshot = playerRef.current?.takeScreenshot();
            if (screenshot) {
              const link = document.createElement("a");
              link.download = "screenshot.png";
              link.href = screenshot;
              link.click();
            }
          }}
        >
          ЁЯУ╕ Screenshot
        </button>

        <button
          onClick={() => {
            const duration = playerRef.current?.getDuration();
            const currentTime = playerRef.current?.getCurrentTime();
            alert(`${currentTime.toFixed(1)}s / ${duration.toFixed(1)}s`);
          }}
        >
          тП▒я╕П Time Info
        </button>
      </div>
    </div>
  );
}
```

### рзй. Imperative API рж╕рж╣ Chart Component ЁЯУК

```jsx
const InteractiveChart = forwardRef(({ data, type = "bar" }, ref) => {
  const chartRef = useRef(null);
  const [chartData, setChartData] = useState(data);
  const [selectedPoint, setSelectedPoint] = useState(null);

  useImperativeHandle(ref, () => ({
    // Data manipulation
    updateData: (newData) => {
      setChartData(newData);
    },

    addDataPoint: (point) => {
      setChartData((prev) => [...prev, point]);
    },

    removeDataPoint: (index) => {
      setChartData((prev) => prev.filter((_, i) => i !== index));
    },

    // Visual controls
    highlightPoint: (index) => {
      setSelectedPoint(index);
      // highlight animation ржпрзЛржЧ ржХрж░рзБржи
      const point = chartRef.current?.querySelector(`[data-index="${index}"]`);
      if (point) {
        point.style.transform = "scale(1.2)";
        point.style.transition = "transform 0.3s ease";
      }
    },

    clearHighlight: () => {
      setSelectedPoint(null);
      const points = chartRef.current?.querySelectorAll("[data-index]");
      points?.forEach((point) => {
        point.style.transform = "scale(1)";
      });
    },

    // Export functionality
    exportAsImage: () => {
      // Chart ржХрзЗ canvas ржП convert ржХрж░рзЗ export ржХрж░рзБржи
      const svg = chartRef.current?.querySelector("svg");
      if (svg) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const data = new XMLSerializer().serializeToString(svg);
        const img = new Image();
        img.onload = () => {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          const link = document.createElement("a");
          link.download = "chart.png";
          link.href = canvas.toDataURL();
          link.click();
        };
        img.src = "data:image/svg+xml;base64," + btoa(data);
      }
    },

    // Animation controls
    animateIn: () => {
      const chart = chartRef.current;
      if (chart) {
        chart.style.opacity = "0";
        chart.style.transform = "translateY(20px)";
        chart.style.transition = "all 0.5s ease";

        setTimeout(() => {
          chart.style.opacity = "1";
          chart.style.transform = "translateY(0)";
        }, 100);
      }
    },

    // Data getters
    getData: () => [...chartData],
    getSelectedPoint: () => selectedPoint,
    getStats: () => ({
      min: Math.min(...chartData.map((d) => d.value)),
      max: Math.max(...chartData.map((d) => d.value)),
      average:
        chartData.reduce((sum, d) => sum + d.value, 0) / chartData.length,
    }),
  }));

  return (
    <div ref={chartRef} className="interactive-chart">
      {/* рж╕рж░рж▓рзАржХрзГржд chart rendering */}
      <svg width="400" height="300">
        {chartData.map((point, index) => (
          <rect
            key={index}
            data-index={index}
            x={index * 40 + 20}
            y={300 - point.value * 2}
            width="30"
            height={point.value * 2}
            fill={selectedPoint === index ? "#ff6b6b" : "#4ecdc4"}
            style={{ cursor: "pointer" }}
            onClick={() => setSelectedPoint(index)}
          />
        ))}
      </svg>
    </div>
  );
});

// ржмрзНржпржмрж╣рж╛рж░
function Dashboard() {
  const chartRef = useRef(null);
  const [data] = useState([
    { label: "Jan", value: 65 },
    { label: "Feb", value: 80 },
    { label: "Mar", value: 95 },
    { label: "Apr", value: 70 },
  ]);

  return (
    <div className="dashboard">
      <InteractiveChart ref={chartRef} data={data} />

      <div className="chart-controls">
        <button onClick={() => chartRef.current?.animateIn()}>
          тЬи Animate
        </button>

        <button onClick={() => chartRef.current?.highlightPoint(2)}>
          ЁЯОп March Highlight ржХрж░рзБржи
        </button>

        <button onClick={() => chartRef.current?.clearHighlight()}>
          ЁЯз╣ Highlight Clear ржХрж░рзБржи
        </button>

        <button onClick={() => chartRef.current?.exportAsImage()}>
          ЁЯТ╛ PNG Export ржХрж░рзБржи
        </button>

        <button
          onClick={() => {
            const stats = chartRef.current?.getStats();
            alert(
              `Min: ${stats.min}, Max: ${
                stats.max
              }, Avg: ${stats.average.toFixed(1)}`
            );
          }}
        >
          ЁЯУК Stats ржжрзЗржЦрж╛ржи
        </button>

        <button
          onClick={() => {
            chartRef.current?.addDataPoint({ label: "May", value: 85 });
          }}
        >
          тЮХ Data ржпрзЛржЧ ржХрж░рзБржи
        </button>
      </div>
    </div>
  );
}
```

---

## ржЙржирзНржиржд Patterns ржУ Tips ЁЯФе

### рзз. ржПржХрж╛ржзрж┐ржХ Refs ржПржХрж╕рж╛ржерзЗ ржХрж░рж╛

```jsx
const ComplexComponent = forwardRef((props, ref) => {
  const containerRef = useRef(null);
  const inputRef = useRef(null);
  const buttonRef = useRef(null);

  useImperativeHandle(ref, () => ({
    // ржПржХрж╛ржзрж┐ржХ element controls expose ржХрж░рзБржи
    focusInput: () => inputRef.current?.focus(),
    clickButton: () => buttonRef.current?.click(),
    scrollContainer: (top) => {
      containerRef.current.scrollTop = top;
    },

    // ржЬржЯрж┐рж▓ operations expose ржХрж░рзБржи
    performComplexAction: async () => {
      inputRef.current?.focus();
      await new Promise((resolve) => setTimeout(resolve, 100));
      containerRef.current?.scrollIntoView();
      buttonRef.current?.click();
    },
  }));

  return (
    <div ref={containerRef}>
      <input ref={inputRef} />
      <button ref={buttonRef}>Action</button>
    </div>
  );
});
```

### рзи. рж╢рж░рзНрждрж╕рж╛ржкрзЗржХрзНрж╖ API Exposure

```jsx
const ConditionalComponent = forwardRef(({ mode = "basic" }, ref) => {
  const elementRef = useRef(null);

  useImperativeHandle(
    ref,
    () => {
      const basicAPI = {
        focus: () => elementRef.current?.focus(),
        getValue: () => elementRef.current?.value || "",
      };

      const advancedAPI = {
        ...basicAPI,
        clear: () => {
          elementRef.current.value = "";
        },
        selectAll: () => elementRef.current?.select(),
        // ржмрж┐ржкржЬрзНржЬржиржХ methods рж╢рзБржзрзБржорж╛рждрзНрж░ advanced mode ржП
        dangerouslySetHTML: (html) => {
          elementRef.current.innerHTML = html;
        },
      };

      return mode === "advanced" ? advancedAPI : basicAPI;
    },
    [mode]
  );

  return <input ref={elementRef} />;
});
```

### рзй. Event-Based API

```jsx
const EventDrivenComponent = forwardRef((props, ref) => {
  const [subscribers, setSubscribers] = useState([]);

  useImperativeHandle(ref, () => ({
    // Event subscription methods
    addEventListener: (event, callback) => {
      setSubscribers((prev) => [...prev, { event, callback }]);
    },

    removeEventListener: (event, callback) => {
      setSubscribers((prev) =>
        prev.filter(
          (sub) => !(sub.event === event && sub.callback === callback)
        )
      );
    },

    // ржХрж╛рж╕рзНржЯржо events trigger ржХрж░рзБржи
    emit: (event, data) => {
      subscribers
        .filter((sub) => sub.event === event)
        .forEach((sub) => sub.callback(data));
    },

    // Component actions ржпрж╛ events trigger ржХрж░рзЗ
    doSomething: () => {
      // Action рж╕ржорзНржкрж╛ржжржи ржХрж░рзБржи
      const result = "Action completed";

      // Subscribers ржХрзЗ notify ржХрж░рзБржи
      ref.current.emit("actionComplete", { result, timestamp: Date.now() });
    },
  }));

  return <div>Event-driven component</div>;
});
```

---

## Performance ржмрж┐ржмрзЗржЪржирж╛рж╕ржорзВрж╣ тЪб

<Callout type="warning" emoji="тЪб">
{<>
**Performance Tips:** - ржмрзНржпржпрж╝ржмрж╣рзБрж▓ imperative methods ржПрж░ ржЬржирзНржп `useCallback`
ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи recreation ржкрзНрж░рждрж┐рж░рзЛржз ржХрж░рждрзЗ - ржЖржкржирж╛рж░ imperative API рждрзЗ ржЬржЯрж┐рж▓
calculations memoize ржХрж░рзБржи - ржШржи ржШржи DOM manipulations ржПрж░ ржмрзНржпрж╛ржкрж╛рж░рзЗ рж╕рждрж░рзНржХ ржерж╛ржХрзБржи -
DOM measurements ржПрж░ ржЬржирзНржп `useLayoutEffect` ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛рж░ ржХржерж╛ ржмрж┐ржмрзЗржЪржирж╛ ржХрж░рзБржи
</>}
</Callout>

```jsx
const OptimizedComponent = forwardRef((props, ref) => {
  const elementRef = useRef(null);
  const expensiveCalculation = useCallback(() => {
    // ржПржЦрж╛ржирзЗ ржнрж╛рж░рзА computation
    return elementRef.current?.getBoundingClientRect();
  }, []);

  useImperativeHandle(
    ref,
    () => ({
      getPosition: expensiveCalculation,
      // ржЕржирзНржпрж╛ржирзНржп methods...
    }),
    [expensiveCalculation]
  );

  return <div ref={elementRef}>Optimized Component</div>;
});
```

---

## useImperativeHandle Testing ЁЯзк

```jsx
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";

test("ржХрж╛рж╕рзНржЯржо API methods expose ржХрж░рж╛ ржЙржЪрж┐ржд", () => {
  let componentRef;

  function TestWrapper() {
    componentRef = useRef(null);
    return <CustomInput ref={componentRef} />;
  }

  render(<TestWrapper />);

  // Exposed methods test ржХрж░рзБржи
  expect(typeof componentRef.current.focus).toBe("function");
  expect(typeof componentRef.current.clear).toBe("function");
  expect(typeof componentRef.current.getValue).toBe("function");

  // Method functionality test ржХрж░рзБржи
  componentRef.current.focus();
  expect(screen.getByRole("textbox")).toHaveFocus();

  // Test ржХрж░рзБржи ржпрзЗ internal DOM expose рж╣ржпрж╝ржирж┐
  expect(componentRef.current.style).toBeUndefined();
  expect(componentRef.current.innerHTML).toBeUndefined();
});
```

---

## рж╕рж╛ржзрж╛рж░ржг ржнрзБрж▓ ржУ ржПржбрж╝рж╛ржирзЛрж░ ржЙржкрж╛ржпрж╝ тЪая╕П

<Callout type="error" emoji="ЁЯЪл">
**ржПржЗ ржнрзБрж▓ржЧрзБрж▓рзЛ ржПржбрж╝рж┐ржпрж╝рзЗ ржЪрж▓рзБржи:**

1. **ржЕрждрж┐рж░рж┐ржХрзНржд expose ржХрж░рж╛** - Internal implementation details expose ржХрж░ржмрзЗржи ржирж╛
2. **forwardRef ржнрзБрж▓рзЗ ржпрж╛ржУржпрж╝рж╛** - `useImperativeHandle` рж╢рзБржзрзБржорж╛рждрзНрж░ `forwardRef` ржПрж░ рж╕рж╛ржерзЗ ржХрж╛ржЬ ржХрж░рзЗ
3. **null refs check ржирж╛ ржХрж░рж╛** - рж╕ржмрж╕ржоржпрж╝ optional chaining (`?.`) ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи
4. **imperative APIs ржЕрждрж┐рж░рж┐ржХрзНржд ржмрзНржпржмрж╣рж╛рж░** - рж╕ржорзНржнржм рж╣рж▓рзЗ declarative patterns ржкржЫржирзНржж ржХрж░рзБржи
5. **API documentation ржирж╛ ржХрж░рж╛** - ржЖржкржирж╛рж░ ржХрж╛рж╕рзНржЯржо API ржПрж░ рж╕рзНржкрж╖рзНржЯ documentation ржкрзНрж░ржпрж╝рзЛржЬржи
</Callout>

### тЭМ ржЦрж╛рж░рж╛ржк ржЙржжрж╛рж╣рж░ржг

```jsx
const BadComponent = forwardRef((props, ref) => {
  const elementRef = useRef(null);

  useImperativeHandle(ref, () => ({
    // ржЕрждрж┐рж░рж┐ржХрзНржд internal stuff expose ржХрж░рж╛
    element: elementRef.current,
    _internalState: someInternalState,
    dangerousMethod: () => {
      // ржирж┐рж░рж╛ржкрждрзНрждрж╛ ржмрзНржпржмрж╕рзНржерж╛ ржЫрж╛ржбрж╝рж╛ржЗ ржмрж┐ржкржЬрзНржЬржиржХ operation
      elementRef.current.remove();
    },
  }));

  return <div ref={elementRef}>Bad Component</div>;
});
```

### тЬЕ ржнрж╛рж▓рзЛ ржЙржжрж╛рж╣рж░ржг

```jsx
const GoodComponent = forwardRef((props, ref) => {
  const elementRef = useRef(null);

  useImperativeHandle(ref, () => ({
    // ржкрж░рж┐рж╖рзНржХрж╛рж░, ржЙржжрзНржжрзЗрж╢рзНржпржкрзНрж░ржгрзЛржжрж┐ржд API
    focus: () => elementRef.current?.focus(),

    scrollIntoView: (options = { behavior: "smooth" }) => {
      elementRef.current?.scrollIntoView(options);
    },

    getMetrics: () => ({
      width: elementRef.current?.offsetWidth || 0,
      height: elementRef.current?.offsetHeight || 0,
      visible: elementRef.current?.offsetParent !== null,
    }),
  }));

  return <div ref={elementRef}>Good Component</div>;
});
```

---

## TypeScript рж╕рж╛ржкрзЛрж░рзНржЯ ЁЯТЩ

```tsx
import React, { useRef, useImperativeHandle, forwardRef } from "react";

// Imperative API interface define ржХрж░рзБржи
interface CustomInputRef {
  focus: () => void;
  clear: () => void;
  getValue: () => string;
  setValue: (value: string) => void;
}

interface CustomInputProps {
  placeholder?: string;
  defaultValue?: string;
  onValueChange?: (value: string) => void;
}

const CustomInput = forwardRef<CustomInputRef, CustomInputProps>(
  ({ placeholder, defaultValue, onValueChange }, ref) => {
    const inputRef = useRef<HTMLInputElement>(null);

    useImperativeHandle(ref, () => ({
      focus: () => {
        inputRef.current?.focus();
      },

      clear: () => {
        if (inputRef.current) {
          inputRef.current.value = "";
          onValueChange?.("");
        }
      },

      getValue: () => {
        return inputRef.current?.value || "";
      },

      setValue: (value: string) => {
        if (inputRef.current) {
          inputRef.current.value = value;
          onValueChange?.(value);
        }
      },
    }));

    return (
      <input
        ref={inputRef}
        type="text"
        placeholder={placeholder}
        defaultValue={defaultValue}
        onChange={(e) => onValueChange?.(e.target.value)}
      />
    );
  }
);

// рж╕ржорзНржкрзВрж░рзНржг type safety рж╕рж╣ ржмрзНржпржмрж╣рж╛рж░
function TypedParent() {
  const inputRef = useRef<CustomInputRef>(null);

  return (
    <div>
      <CustomInput
        ref={inputRef}
        placeholder="ржХрж┐ржЫрзБ ржЯрж╛ржЗржк ржХрж░рзБржи..."
        onValueChange={(value) => console.log("Value:", value)}
      />

      <button onClick={() => inputRef.current?.focus()}>
        Input Focus ржХрж░рзБржи
      </button>

      <button
        onClick={() => {
          const value = inputRef.current?.getValue();
          alert(`ржмрж░рзНрждржорж╛ржи value: ${value}`);
        }}
      >
        Value ржкрж╛ржи
      </button>
    </div>
  );
}
```

---

ржирж┐ржЪрзЗ ржжрзЗржУрзЯрж╛ рж╣рж▓рзЛ ржЙржкрж░рзЗрж░ рж▓рзЗржЦрж╛ ржмрж╛ржВрж▓рж╛рзЯ ржЕржирзБржмрж╛ржж ржХрж░рж╛ рж╕ржВрж╕рзНржХрж░ржг:

---

## рж╕рзЗрж░рж╛ ржЕржирзБрж╢рзАрж▓ржирзЗрж░ рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк ЁЯУЭ

<Callout type="info" emoji="ЁЯТб">
**рж╕рзЛржирж╛рж▓рзА ржирж┐рзЯржорж╛ржмрж▓рж┐:**

1. **ржпрзЗржЯрзБржХрзБ ржкрзНрж░рзЯрзЛржЬржи, рж╢рзБржзрзБржорж╛рждрзНрж░ рж╕рзЗржЯрзБржХрзБржЗ ржкрзНрж░ржХрж╛рж╢ ржХрж░рзБржи** ЁЯОп
2. **ржирж┐рж░рж╛ржкржж рж░рж╛ржЦрзБржи** - ржЙржкржпрзБржХрзНржд рждрзНрж░рзБржЯрж┐ ржмрзНржпржмрж╕рзНржерж╛ржкржирж╛ ржПржмржВ ржпрж╛ржЪрж╛ржЗ ржпрзЛржЧ ржХрж░рзБржи ЁЯЫбя╕П
3. **рж╕ржмржХрж┐ржЫрзБ ржбржХрзБржорзЗржирзНржЯ ржХрж░рзБржи** - ржЖржкржирж╛рж░ API-рж░ ржкрж░рж┐рж╖рзНржХрж╛рж░ ржбржХрзБржорзЗржирзНржЯрзЗрж╢ржи ржерж╛ржХрж╛ ржЖржмрж╢рзНржпржХ ЁЯУЪ
4. **ржкрзНрж░ржержорзЗ ржнрж╛ржмрзБржи ржбрж┐ржХрзНрж▓рзЗрзЯрж╛рж░рзЗржЯрж┐ржн ржнрж╛ржмрзЗ** - ржЗржорзНржкрзЗрж░рзЗржЯрж┐ржн API ржХрзЗржмрж▓ рждржЦржиржЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи ржпржЦржи ржЬрж░рзБрж░рж┐ ЁЯдФ
5. **ржкрж░рзНржпрж╛ржкрзНрждржнрж╛ржмрзЗ ржЯрзЗрж╕рзНржЯ ржХрж░рзБржи** - API ржПржмржВ ржПрж░ ржкрзНрж░рж╛ржирзНрждрж┐ржХ ржХрзЗрж╕ржЧрзБрж▓рзЛржУ ржкрж░рзАржХрзНрж╖рж╛ ржХрж░рзБржи ЁЯзк
6. **TypeScript ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи** - ржЯрж╛ржЗржк рж╕рзЗржлржЯрж┐ ржЕржирзЗржХ ржмрж╛ржЧ рж░рзЛржз ржХрж░рзЗ ЁЯТЩ

</Callout>

---

## рж░рж┐рж╕рзЛрж░рзНрж╕ ржУ ржЖрж░ржУ ржкрзЬрж╛рж╢рзЛржирж╛ ЁЯУЪ

- [React ржбржХрзБржорзЗржирзНржЯрзЗрж╢ржи: useImperativeHandle](https://react.dev/reference/react/useImperativeHandle) ЁЯУЦ
- [React ржбржХрзБржорзЗржирзНржЯрзЗрж╢ржи: forwardRef](https://react.dev/reference/react/forwardRef) ЁЯФЧ
- [React ржбржХрзБржорзЗржирзНржЯрзЗрж╢ржи: Refs ржжрж┐рзЯрзЗ DOM ржорзНржпрж╛ржирж┐ржкрзБрж▓рзЗрж╢ржи](https://react.dev/learn/manipulating-the-dom-with-refs) ЁЯОп
- [Advanced Patterns with useImperativeHandle тАУ Kent C. Dodds](https://kentcdodds.com/blog/imperative-react) ЁЯФе

---

## рж╕рж╛рж░рж╛ржВрж╢ ЁЯОЙ

`useImperativeHandle` рж╣рж▓ ржЖржкржирж╛рж░ ржЧрзЛржкржи ржЕрж╕рзНрждрзНрж░ тАФ ржпрж╛ ржЖржкржирж╛ржХрзЗ React ржХржорзНржкрзЛржирзЗржирзНржЯрзЗ ржкрж░рж┐рж╢рзАрж▓рж┐ржд, ржирж┐рзЯржирзНрждрзНрж░рж┐ржд API рждрзИрж░рж┐ ржХрж░рждрзЗ рж╕рж╛рж╣рж╛ржпрзНржп ржХрж░рзЗ! ржПржЯрж┐ ржЖржкржирж╛ржХрзЗ рж╕ржХрзНрж╖ржо ржХрж░рзЗ:

- **ржирж┐рзЯржирзНрждрзНрж░рж┐ржд ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕** ЁЯФР тАФ ржкрзНржпрж╛рж░рзЗржирзНржЯ ржХржорзНржкрзЛржирзЗржирзНржЯрзЗрж░ ржЬржирзНржп рж╢рзБржзрзБржорж╛рждрзНрж░ ржкрзНрж░рзЯрзЛржЬржирзАрзЯ ржЕржВрж╢ ржкрзНрж░ржХрж╛рж╢ ржХрж░рждрзЗ
- **ржЬржЯрж┐рж▓рждрж╛ ржЧрзЛржкржи ржХрж░рж╛** ЁЯОн тАФ ржЕржнрзНржпржирзНрждрж░рзАржг ржмрж╛рж╕рзНрждржмрж╛рзЯржирзЗрж░ ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд ржмрж╛ржЗрж░рзЗрж░ ржерзЗржХрзЗ ржЖрзЬрж╛рж▓ рж░рж╛ржЦрждрзЗ
- **ржЙрждрзНрждржо API рждрзИрж░рж┐** ЁЯЫая╕П тАФ ржХржорзНржкрзЛржирзЗржирзНржЯрзЗрж░ ржЬржирзНржп рж╕рзНржмржЬрзНржЮрж╛ржд ржЗржирзНржЯрж╛рж░ржлрзЗрж╕ ржбрж┐ржЬрж╛ржЗржи ржХрж░рждрзЗ
- **ржПржиржХрзНржпрж╛ржкрж╕рзБрж▓рзЗрж╢ржи ржмржЬрж╛рзЯ рж░рж╛ржЦрж╛** ЁЯУж тАФ рж╕ржлржЯржУрзЯрзНржпрж╛рж░ ржЗржЮрзНржЬрж┐ржирж┐ржпрж╝рж╛рж░рж┐ржВрзЯрзЗрж░ рж╕ржарж┐ржХ ржирж┐рзЯржо ржорзЗржирзЗ ржЪрж▓рждрзЗ

ржПржЗ рж╣рзБржХржЯрж┐ ржЖржпрж╝рждрзНрждрзЗ ржЖржирзБржи, ржЖрж░ рждрзИрж░рж┐ ржХрж░рзБржи ржЖрж░ржУ ржкрзНрж░ржлрзЗрж╢ржирж╛рж▓, рж╕рж╣ржЬ-рж░ржХрзНрж╖ржгржпрзЛржЧрзНржп React ржЕрзНржпрж╛ржкрзНрж▓рж┐ржХрзЗрж╢ржи! ЁЯЪАтЬи

**рж╢рзБржн ржХрзЛржбрж┐ржВ! ЁЯТ╗ЁЯТЦ**
