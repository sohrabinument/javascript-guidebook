# ЁЯОп React Refs ржПрж░ рж╕рж╛ржерзЗ DOM Manipulation рж╢рж┐ржЦрзБржи

ржЖржкржирж┐ ржХрж┐ ржХржЦржирзЛ ржЕржирзБржнржм ржХрж░рзЗржЫрзЗржи ржпрзЗ ржЖржкржирж┐ React ржПрж░ рж╕рж╛ржерзЗ ржпрзБржжрзНржз ржХрж░ржЫрзЗржи ржпржЦржи ржЖржкржирж┐ рж╢рзБржзрзБ ржПржХржЯрж┐ input ржлрзЛржХрж╛рж╕ ржХрж░рждрзЗ ржмрж╛ ржХрзЛржирзЛ section ржП scroll ржХрж░рждрзЗ ржЪрж╛ржи? **refs** ржПрж░ ржЬржЧрждрзЗ рж╕рзНржмрж╛ржЧрждржо тАУ DOM ржП ржЖржкржирж╛рж░ рж╕рж░рж╛рж╕рж░рж┐ ржкрзНрж░ржмрзЗрж╢ржжрзНржмрж╛рж░! ЁЯЪА

refs ржХрзЗ React ржПрж░ ржПржЗ ржХржерж╛ ржмрж▓рж╛рж░ ржорждрзЛ ржнрж╛ржмрзБржи: _"ржарж┐ржХ ржЖржЫрзЗ, ржХржЦржирзЛ ржХржЦржирзЛ рждрзЛржорж╛рж░ ржирж┐ржпрж╝ржо ржнрж╛ржЩрждрзЗ рж╣ржпрж╝ред ржПржЗ ржирж╛ржУ DOM ржПрж░ backstage pass!"_

---

## ЁЯдФ ржХрзЗржи ржЖржорж╛ржжрзЗрж░ Refs ржкрзНрж░ржпрж╝рзЛржЬржи?

React declaratively UI state ржкрж░рж┐ржЪрж╛рж▓ржирж╛ ржХрж░рждрзЗ ржжрзБрж░рзНржжрж╛ржирзНржд, ржХрж┐ржирзНрждрзБ ржХржЦржирзЛ ржХржЦржирзЛ ржЖржкржирж╛рж░ ржкрзНрж░ржпрж╝рзЛржЬржи:

- ЁЯОп ржПржХржЯрж┐ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ input field ржлрзЛржХрж╛рж╕ ржХрж░рж╛
- ЁЯУП ржПржХржЯрж┐ element ржПрж░ dimensions ржкрж░рж┐ржорж╛ржк ржХрж░рж╛
- ЁЯОм Imperatively animations ржЯрзНрж░рж┐ржЧрж╛рж░ ржХрж░рж╛
- ЁЯУЬ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ content ржП scroll ржХрж░рж╛
- ЁЯОо Third-party DOM libraries ржПрж░ рж╕рж╛ржерзЗ integrate ржХрж░рж╛

ржПржЦрж╛ржирзЗржЗ refs ржПрж░ ржЬрзМрж▓рзБрж╕! ржПржЧрзБрж▓рзЛ рж╕рж░рж╛рж╕рж░рж┐ DOM access ржПрж░ ржЬржирзНржп ржЖржкржирж╛рж░ escape hatchред

---

## ЁЯФН Ref ржЖрж╕рж▓рзЗ ржХрзА?

ржПржХржЯрж┐ **ref** рж╣рж▓рзЛ ржПржХржЯрж┐ persistent box ржПрж░ ржорждрзЛ ржпрж╛ ржПржХржЯрж┐ DOM element (ржмрж╛ ржпрзЗржХрзЛржирзЛ mutable value) ржПрж░ reference рж░рж╛ржЦрзЗред State ржПрж░ ржмрж┐ржкрж░рзАрждрзЗ, ref ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж▓рзЗ re-render ржЯрзНрж░рж┐ржЧрж╛рж░ рж╣ржпрж╝ ржирж╛ тАУ ржПржЯрж┐ рж╢рзБржзрзБ renders ржЬрзБржбрж╝рзЗ ржХрж┐ржЫрзБ "ржоржирзЗ рж░рж╛ржЦрж╛рж░" ржПржХржЯрж┐ ржЙржкрж╛ржпрж╝ред

```jsx
import { useRef } from "react";

function MyComponent() {
  // ржПржЯрж┐ ржПржХржЯрж┐ "ржмрж╛ржХрзНрж╕" рждрзИрж░рж┐ ржХрж░рзЗ ржпрж╛ ржЖржорж╛ржжрзЗрж░ DOM element ржзрж░рзЗ рж░рж╛ржЦржмрзЗ
  const elementRef = useRef(null);

  // elementRef.current ржкрзНрж░рж╛ржержорж┐ржХржнрж╛ржмрзЗ null рж╣ржмрзЗ
  // React ржПржЯрж┐ attach ржХрж░рж╛рж░ ржкрж░рзЗ elementRef.current ржкрзНрж░ржХрзГржд DOM node рж╣ржмрзЗ
}
```

---

## ЁЯОо ржЖржкржирж╛рж░ ржкрзНрж░ржержо Ref: ржЬрж╛ржжрзБржХрж░рзА Focus Button

ржЪрж▓рзБржи classic ржЙржжрж╛рж╣рж░ржг ржжрж┐ржпрж╝рзЗ рж╢рзБрж░рзБ ржХрж░рж┐ тАУ ржПржХржЯрж┐ input field ржлрзЛржХрж╛рж╕ ржХрж░рж╛:

```jsx
import { useRef } from "react";

export default function FocusDemo() {
  const inputRef = useRef(null);

  function handleFocus() {
    // рж╕рж░рж╛рж╕рж░рж┐ DOM manipulation! ЁЯОп
    inputRef.current.focus();
  }

  return (
    <div style={{ padding: "20px" }}>
      <input
        ref={inputRef}
        placeholder="ржЖржорж╛ржХрзЗ ржлрзЛржХрж╛рж╕ ржХрж░рждрзЗ ржмрж╛ржЯржирзЗ ржХрзНрж▓рж┐ржХ ржХрж░рзБржи!"
        style={{
          padding: "10px",
          marginRight: "10px",
          borderRadius: "4px",
          border: "2px solid #ddd",
        }}
      />
      <button
        onClick={handleFocus}
        style={{
          padding: "10px 20px",
          backgroundColor: "#007acc",
          color: "white",
          border: "none",
          borderRadius: "4px",
          cursor: "pointer",
        }}
      >
        тЬи Input ржлрзЛржХрж╛рж╕ ржХрж░рзБржи
      </button>
    </div>
  );
}
```

**ржПржЦрж╛ржирзЗ ржХрзА ржШржЯржЫрзЗ?**

1. `useRef(null)` ржЖржорж╛ржжрзЗрж░ ref рждрзИрж░рж┐ ржХрж░рзЗ null ржПрж░ ржкрзНрж░рж╛ржержорж┐ржХ ржорж╛ржи рж╕рж╣
2. `ref={inputRef}` React ржХрзЗ ржмрж▓рзЗ: "ржПржЗ DOM element ржЯрж┐ ржЖржорж╛рж░ ref box ржП рж░рж╛ржЦрзЛ!"
3. `inputRef.current.focus()` input ржлрзЛржХрж╛рж╕ ржХрж░рждрзЗ рж╕рж░рж╛рж╕рж░рж┐ DOM API ржХрж▓ ржХрж░рзЗ

---

## ЁЯОв Smooth Scrolling ржЕрзНржпрж╛ржбржнрзЗржЮрзНржЪрж╛рж░

рж╕рзЗржЗ рж╕ржирзНрждрзЛрж╖ржЬржиржХ smooth scroll effects рждрзИрж░рж┐ ржХрж░рждрзЗ ржЪрж╛ржи? Refs ржПржЯрж┐ ржЕржмрж┐рж╢рзНржмрж╛рж╕рзНржпржнрж╛ржмрзЗ рж╕рж╣ржЬ ржХрж░рзЗ рждрзЛрж▓рзЗ:

```jsx
import { useRef } from "react";

export default function ScrollingDemo() {
  const topRef = useRef(null);
  const middleRef = useRef(null);
  const bottomRef = useRef(null);

  const scrollToSection = (ref) => {
    ref.current?.scrollIntoView({
      behavior: "smooth",
      block: "start",
    });
  };

  return (
    <div>
      {/* Navigation */}
      <nav
        style={{
          position: "fixed",
          top: 0,
          left: 0,
          right: 0,
          backgroundColor: "white",
          padding: "10px",
          boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
          zIndex: 1000,
        }}
      >
        <button onClick={() => scrollToSection(topRef)}>ЁЯПа рж╢рзАрж░рзНрж╖</button>
        <button onClick={() => scrollToSection(middleRef)}>ЁЯПФя╕П ржоржзрзНржп</button>
        <button onClick={() => scrollToSection(bottomRef)}>ЁЯПЦя╕П ржирж┐ржорзНржи</button>
      </nav>

      {/* Content Sections */}
      <section
        ref={topRef}
        style={{
          height: "100vh",
          backgroundColor: "#e3f2fd",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          fontSize: "2rem",
        }}
      >
        ЁЯПа рж╢рзАрж░рзНрж╖рзЗ рж╕рзНржмрж╛ржЧрждржо!
      </section>

      <section
        ref={middleRef}
        style={{
          height: "100vh",
          backgroundColor: "#f3e5f5",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          fontSize: "2rem",
        }}
      >
        ЁЯПФя╕П ржЖржкржирж┐ ржоржзрзНржпрзЗ ржкрзМржБржЫрзЗржЫрзЗржи!
      </section>

      <section
        ref={bottomRef}
        style={{
          height: "100vh",
          backgroundColor: "#e8f5e8",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          fontSize: "2rem",
        }}
      >
        ЁЯПЦя╕П ржкрзГржерж┐ржмрзАрж░ ржирж┐ржЪрзЗ!
      </section>
    </div>
  );
}
```

> **ржкрзНрж░рзЛ ржЯрж┐ржк:** `ref.current?.scrollIntoView()` ржП optional chaining (`?.`) ref ржПржЦржирзЛ attach ржирж╛ рж╣рж▓рзЗ error ржкрзНрж░рждрж┐рж░рзЛржз ржХрж░рзЗ!

---

## ЁЯОи Dynamic Refs рж╕рж╣ Image Gallery

ржПржЦрж╛ржирзЗ ржмрж┐рж╖ржпрж╝ржЧрзБрж▓рзЛ рж░рзЛржорж╛ржЮрзНржЪржХрж░ рж╣ржпрж╝рзЗ ржУржарзЗ тАУ dynamically ржПржХрж╛ржзрж┐ржХ refs ржкрж░рж┐ржЪрж╛рж▓ржирж╛ ржХрж░рж╛:

```jsx
import { useRef } from "react";

export default function ImageGallery() {
  // Image data ржПрж░ array
  const images = [
    {
      id: 1,
      url: "https://picsum.photos/300/200?random=1",
      title: "ржкрж░рзНржмрждрзЗрж░ рж╣рзНрж░ржж",
    },
    {
      id: 2,
      url: "https://picsum.photos/300/200?random=2",
      title: "ржмржирзЗрж░ ржкрже",
    },
    {
      id: 3,
      url: "https://picsum.photos/300/200?random=3",
      title: "рж╕ржорзБржжрзНрж░рзЗрж░ ржврзЗржЙ",
    },
    {
      id: 4,
      url: "https://picsum.photos/300/200?random=4",
      title: "ржорж░рзБржнрзВржорж┐рж░ рж╕рзВрж░рзНржпрж╛рж╕рзНржд",
    },
  ];

  // ржкрзНрж░рждрж┐ржЯрж┐ image ржПрж░ ржЬржирзНржп refs рждрзИрж░рж┐ ржХрж░рзБржи
  const imageRefs = useRef({});

  const scrollToImage = (imageId) => {
    imageRefs.current[imageId]?.scrollIntoView({
      behavior: "smooth",
      block: "center",
    });
  };

  return (
    <div style={{ padding: "20px" }}>
      <h2>ЁЯЦ╝я╕П ржлржЯрзЛ ржЧрзНржпрж╛рж▓рж╛рж░рж┐</h2>

      {/* Quick Navigation */}
      <div style={{ marginBottom: "20px" }}>
        {images.map((image) => (
          <button
            key={image.id}
            onClick={() => scrollToImage(image.id)}
            style={{
              margin: "5px",
              padding: "8px 12px",
              backgroundColor: "#f0f0f0",
              border: "1px solid #ddd",
              borderRadius: "4px",
              cursor: "pointer",
            }}
          >
            ЁЯУ╖ {image.title}
          </button>
        ))}
      </div>

      {/* Image Gallery */}
      <div>
        {images.map((image, index) => (
          <div
            key={image.id}
            ref={(el) => (imageRefs.current[image.id] = el)}
            style={{
              marginBottom: "40px",
              padding: "20px",
              border: "2px solid #eee",
              borderRadius: "8px",
              textAlign: "center",
            }}
          >
            <h3>{image.title}</h3>
            <img
              src={image.url}
              alt={image.title}
              style={{
                maxWidth: "100%",
                borderRadius: "4px",
                boxShadow: "0 4px 8px rgba(0,0,0,0.1)",
              }}
            />
            <p>рж╕рзБржирзНржжрж░ ржЫржмрж┐ #{index + 1}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
```

**ржорзВрж▓ ржХрзМрж╢рж▓:** `ref={(el) => imageRefs.current[image.id] = el}` ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ dynamically ржПржХржЯрж┐ object ржП refs assign ржХрж░рж╛!

---

## ЁЯОк Interactive Playground: Text Manipulator

ржЪрж▓рзБржи ржПржоржи ржХрж┐ржЫрзБ ржоржЬрж╛рж░ рждрзИрж░рж┐ ржХрж░рж┐ ржпрж╛ ржПржХрж╛ржзрж┐ржХ ref use case ржкрзНрж░ржжрж░рзНрж╢ржи ржХрж░рзЗ:

```jsx
import { useRef, useState } from "react";

export default function TextPlayground() {
  const textareaRef = useRef(null);
  const [measurements, setMeasurements] = useState({});

  const focusTextarea = () => {
    textareaRef.current.focus();
  };

  const selectAllText = () => {
    textareaRef.current.select();
  };

  const measureTextarea = () => {
    const element = textareaRef.current;
    setMeasurements({
      width: element.offsetWidth,
      height: element.offsetHeight,
      scrollHeight: element.scrollHeight,
      textLength: element.value.length,
    });
  };

  const insertText = (text) => {
    const element = textareaRef.current;
    const start = element.selectionStart;
    const end = element.selectionEnd;
    const currentValue = element.value;

    element.value =
      currentValue.slice(0, start) + text + currentValue.slice(end);
    element.focus();
    element.setSelectionRange(start + text.length, start + text.length);
  };

  return (
    <div style={{ padding: "20px", maxWidth: "600px" }}>
      <h2>ЁЯОк ржЯрзЗржХрзНрж╕ржЯ ржорзНржпрж╛ржирж┐ржкрзБрж▓рзЗрж╢ржи ржкрзНрж▓рзЗржЧрзНрж░рж╛ржЙржирзНржб</h2>

      <textarea
        ref={textareaRef}
        placeholder="ржПржЦрж╛ржирзЗ ржЯрж╛ржЗржк ржХрж░рж╛ рж╢рзБрж░рзБ ржХрж░рзБржи... ржЕржержмрж╛ ржирж┐ржЪрзЗрж░ ржмрж╛ржЯржиржЧрзБрж▓рзЛ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи!"
        style={{
          width: "100%",
          height: "200px",
          padding: "12px",
          fontSize: "16px",
          border: "2px solid #ddd",
          borderRadius: "8px",
          resize: "vertical",
          fontFamily: "monospace",
        }}
        defaultValue="рж╣рзНржпрж╛рж▓рзЛ! refs ржПрж░ ржХрж╛рж░рзНржпржХрж╛рж░рж┐рждрж╛ ржжрзЗржЦрждрзЗ ржирж┐ржЪрзЗрж░ ржмрж╛ржЯржиржЧрзБрж▓рзЛ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржи! ЁЯЪА"
      />

      <div style={{ marginTop: "15px" }}>
        <h3>ЁЯОп ржирж┐ржпрж╝ржирзНрждрзНрж░ржг ржХрж╛рж░рзНржпржХрзНрж░ржо</h3>
        <button onClick={focusTextarea} style={buttonStyle}>
          ЁЯОп ржлрзЛржХрж╛рж╕
        </button>
        <button onClick={selectAllText} style={buttonStyle}>
          ЁЯУЭ рж╕ржм ржирж┐рж░рзНржмрж╛ржЪржи
        </button>
        <button onClick={() => insertText("тЬи ржЬрж╛ржжрзБ! тЬи")} style={buttonStyle}>
          тЬи ржЬрж╛ржжрзБ ржврзЛржХрж╛ржи
        </button>
        <button onClick={measureTextarea} style={buttonStyle}>
          ЁЯУП ржкрж░рж┐ржорж╛ржк
        </button>
      </div>

      {Object.keys(measurements).length > 0 && (
        <div
          style={{
            marginTop: "15px",
            padding: "12px",
            backgroundColor: "#f8f9fa",
            borderRadius: "6px",
            border: "1px solid #e9ecef",
          }}
        >
          <h4>ЁЯУК ржкрж░рж┐ржорж╛ржкрж╕ржорзВрж╣:</h4>
          <ul style={{ margin: 0, paddingLeft: "20px" }}>
            <li>ржкрзНрж░рж╕рзНрже: {measurements.width}px</li>
            <li>ржЙржЪрзНржЪрждрж╛: {measurements.height}px</li>
            <li>Scroll ржЙржЪрзНржЪрждрж╛: {measurements.scrollHeight}px</li>
            <li>ржЯрзЗржХрзНрж╕ржЯрзЗрж░ ржжрзИрж░рзНржШрзНржп: {measurements.textLength} ржЕржХрзНрж╖рж░</li>
          </ul>
        </div>
      )}
    </div>
  );
}

const buttonStyle = {
  margin: "5px",
  padding: "8px 16px",
  backgroundColor: "#007acc",
  color: "white",
  border: "none",
  borderRadius: "4px",
  cursor: "pointer",
  fontSize: "14px",
};
```

---

## тЪая╕П рж╕рж╛ржзрж╛рж░ржг ржлрж╛ржБржж ржПржмржВ ржХрзАржнрж╛ржмрзЗ рж╕рзЗржЧрзБрж▓рзЛ ржПржбрж╝рж╛ржирзЛ ржпрж╛ржпрж╝

### ЁЯЪл ржХрж░ржмрзЗржи ржирж╛: рж╕рж░рж╛рж╕рж░рж┐ Children ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж╛

```jsx
// тЭМ ржПржЯрж┐ ржХрж░ржмрзЗржи ржирж╛
function BadExample() {
  const divRef = useRef(null);

  const addChild = () => {
    // ржПржЯрж┐ React ржПрж░ mental model ржнрзЗржЩрзЗ ржжрзЗржпрж╝!
    divRef.current.appendChild(document.createElement("p"));
  };

  return <div ref={divRef} />;
}
```

### тЬЕ ржХрж░рзБржи: React ржХрзЗ DOM Structure ржкрж░рж┐ржЪрж╛рж▓ржирж╛ ржХрж░рждрзЗ ржжрж┐ржи

```jsx
// тЬЕ ржмрж░ржВ ржПржЯрж┐ ржХрж░рзБржи
function GoodExample() {
  const [items, setItems] = useState([]);

  const addItem = () => {
    setItems((prev) => [...prev, `ржЖржЗржЯрзЗржо ${prev.length + 1}`]);
  };

  return (
    <div>
      {items.map((item, index) => (
        <p key={index}>{item}</p>
      ))}
      <button onClick={addItem}>ржЖржЗржЯрзЗржо ржпрзЛржЧ ржХрж░рзБржи</button>
    </div>
  );
}
```

### ЁЯХ░я╕П рж╕ржоржпрж╝ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг

```jsx
// тЪая╕П рж╕ржоржпрж╝рзЗрж░ рж╕рж╛ржерзЗ рж╕рждрж░рзНржХ ржерж╛ржХрзБржи
function TimingExample() {
  const inputRef = useRef(null);

  useEffect(() => {
    // тЭМ ржПржЯрж┐ ржХрж╛ржЬ ржирж╛ржУ ржХрж░рждрзЗ ржкрж╛рж░рзЗ - ref ржПржЦржирзЛ attach рж╣ржпрж╝ржирж┐
    inputRef.current.focus();
  }, []);

  useEffect(() => {
    // тЬЕ ржПржЯрж┐ ржирж┐рж░рж╛ржкржж - render ржПрж░ ржкрж░рзЗ ржЪрж▓рзЗ
    if (inputRef.current) {
      inputRef.current.focus();
    }
  });

  return <input ref={inputRef} />;
}
```

---

## ЁЯОп ржХржЦржи Refs ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗржи: ржЖржкржирж╛рж░ decision tree

```mermaid
graph TD
    A[DOM ржПрж░ рж╕рж╛ржерзЗ interact ржХрж░рждрзЗ рж╣ржмрзЗ?] -->|рж╣рзНржпрж╛ржБ| B[ржХрзА ржзрж░ржирзЗрж░ interaction?]
    A -->|ржирж╛| C[ржирж┐ржпрж╝ржорж┐ржд React state ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи]

    B --> D[Elements Focus/Blur ржХрж░рж╛]
    B --> E[Elements ржП Scroll ржХрж░рж╛]
    B --> F[Dimensions ржкрж░рж┐ржорж╛ржк ржХрж░рж╛]
    B --> G[Animations ржЯрзНрж░рж┐ржЧрж╛рж░ ржХрж░рж╛]
    B --> H[3rd party libs integrate ржХрж░рж╛]

    D --> I[Refs ржПрж░ ржЬржирзНржп ржирж┐ржЦрзБржБржд! ЁЯОп]
    E --> I
    F --> I
    G --> I
    H --> I

    B --> J[DOM elements ржпрзЛржЧ/рж╕рж░рж╛ржирзЛ]
    B --> K[Element content ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж╛]
    J --> L[ржмрж░ржВ React state ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи ЁЯЪл]
    K --> L
```

---

## ЁЯЪА ржЙржирзНржиржд ржкрзНржпрж╛ржЯрж╛рж░рзНржи: Forwarding Refs

ржХржЦржирзЛ ржХржЦржирзЛ ржЖржкржирж╛рж░ components ржПрж░ ржоржзрзНржп ржжрж┐ржпрж╝рзЗ refs ржкрж╛рж╕ ржХрж░рждрзЗ рж╣ржпрж╝:

```jsx
import { forwardRef, useRef } from "react";

// ржХрж╛рж╕рзНржЯржо input component ржпрж╛ рждрж╛рж░ ref forward ржХрж░рзЗ
const FancyInput = forwardRef((props, ref) => (
  <input
    ref={ref}
    {...props}
    style={{
      padding: "12px",
      border: "2px solid #007acc",
      borderRadius: "6px",
      fontSize: "16px",
    }}
  />
));

// Forwarded ref ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзА parent component
function App() {
  const inputRef = useRef(null);

  return (
    <div>
      <FancyInput ref={inputRef} placeholder="ржЖржорж┐ ржПржХржЯрж┐ ржЕржнрж┐ржЬрж╛ржд input!" />
      <button onClick={() => inputRef.current?.focus()}>
        ржЕржнрж┐ржЬрж╛ржд Input ржлрзЛржХрж╛рж╕ ржХрж░рзБржи
      </button>
    </div>
  );
}
```

---

## ЁЯУЪ ржжрзНрж░рзБржд рж░рзЗржлрж╛рж░рзЗржирзНрж╕

| ржмрзНржпржмрж╣рж╛рж░рзЗрж░ ржХрзНрж╖рзЗрждрзНрж░           | ржЙржжрж╛рж╣рж░ржг                                       | ржХржЦржи ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗржи                     |
| --------------------------- | -------------------------------------------- | ------------------------------------- |
| **Focus ржкрж░рж┐ржЪрж╛рж▓ржирж╛**          | `inputRef.current.focus()`                   | Forms, accessibility, user experience |
| **Scrolling**               | `elementRef.current.scrollIntoView()`        | Navigation, smooth scrolling effects  |
| **ржкрж░рж┐ржорж╛ржкрж╕ржорзВрж╣**              | `elementRef.current.offsetHeight`            | Dynamic layouts, animations           |
| **Animations**              | CSS animations ржмрж╛ Web Animations API ржЯрзНрж░рж┐ржЧрж╛рж░ | ржЬржЯрж┐рж▓ interactions                     |
| **Third-party Integration** | D3, Chart.js ржПрж░ ржорждрзЛ libraries attach ржХрж░рж╛     | ржпржЦржи imperative APIs ржкрзНрж░ржпрж╝рзЛржЬржи          |

---

## ЁЯОЙ ржорзВрж▓ ржмрж┐рж╖ржпрж╝рж╕ржорзВрж╣

- ЁЯОп **Refs рж╣рж▓рзЛ ржЖржкржирж╛рж░ DOM access pass** тАУ imperative operations ржПрж░ ржЬржирзНржп ржПржЧрзБрж▓рзЛ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи
- ЁЯФД **ржПржЧрзБрж▓рзЛ re-render ржЯрзНрж░рж┐ржЧрж╛рж░ ржХрж░рзЗ ржирж╛** тАУ UI ржХрзЗ ржкрзНрж░ржнрж╛ржмрж┐ржд ржирж╛ ржХрж░рж╛ values ржПрж░ ржЬржирзНржп ржирж┐ржЦрзБржБржд
- ЁЯОк **Focus, scroll, ржПржмржВ measurements ржПрж░ ржЬржирзНржп ржжрзБрж░рзНржжрж╛ржирзНржд** тАУ ржпрзЗржЧрзБрж▓рзЛ React declaratively handle ржХрж░рзЗ ржирж╛
- ЁЯЪл **DOM structure ржкрж░рж┐ржмрж░рзНрждржи ржХрж░ржмрзЗржи ржирж╛** тАУ React ржХрзЗ рж╕рзЗржЯрж╛ ржкрж░рж┐ржЪрж╛рж▓ржирж╛ ржХрж░рждрзЗ ржжрж┐ржи
- тЪб **рж╕рж░рзНржмржжрж╛ ref ржПрж░ ржЕрж╕рзНрждрж┐рждрзНржм ржкрж░рзАржХрзНрж╖рж╛ ржХрж░рзБржи** тАУ ржирж┐рж░рж╛ржкрждрзНрждрж╛рж░ ржЬржирзНржп optional chaining ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи
- ЁЯФЧ **ржкрзБржирж░рзНржмрзНржпржмрж╣рж╛рж░ржпрзЛржЧрзНржп components рждрзИрж░рж┐ ржХрж░рж╛рж░ рж╕ржоржпрж╝ refs forward ржХрж░рзБржи** тАУ ref chains ржмржЬрж╛ржпрж╝ рж░рж╛ржЦрзБржи

---

## ЁЯМЯ ржкрж░ржмрж░рзНрждрзА ржХрзА?

ржПржЦржи ржпрзЗрж╣рзЗрждрзБ ржЖржкржирж┐ refs ржЖржпрж╝рждрзНржд ржХрж░рзЗржЫрзЗржи, ржПржЧрзБрж▓рзЛ рждрзИрж░рж┐ ржХрж░рж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржи:

- ЁЯОо Focus trapping рж╕рж╣ ржПржХржЯрж┐ ржХрж╛рж╕рзНржЯржо modal
- ЁЯУК Resize detection рж╕рж╣ ржПржХржЯрж┐ chart component
- ЁЯОи ржПржХржЯрж┐ infinite scroll component
- ЁЯОк ржПржХржЯрж┐ drag-and-drop interface

рж╢рзБржн ржХрзЛржбрж┐ржВ! ЁЯЪАтЬи

---

import { Callout } from "nextra/components";

<Callout type="info" emoji="ЁЯТб">
  **ржкрзНрж░рзЛ ржЯрж┐ржк:** Refs accessible components рждрзИрж░рж┐рж░ ржЬржирзНржп ржирж┐ржЦрзБржБржд! Focus flow
  ржкрж░рж┐ржЪрж╛рж▓ржирж╛, screen readers ржПрж░ ржХрж╛ржЫрзЗ ржкрж░рж┐ржмрж░рзНрждржи announce ржХрж░рж╛, ржПржмржВ keyboard
  navigation patterns рждрзИрж░рж┐ ржХрж░рждрзЗ ржПржЧрзБрж▓рзЛ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржиред
</Callout>

<Callout type="warning" emoji="тЪая╕П">
  **ржоржирзЗ рж░рж╛ржЦржмрзЗржи:** ржмржбрж╝ ржХрзНрж╖ржорждрж╛рж░ рж╕рж╛ржерзЗ ржЖрж╕рзЗ ржмржбрж╝ ржжрж╛ржпрж╝рж┐рждрзНржм! Refs ржЖржкржирж╛ржХрзЗ рж╕рж░рж╛рж╕рж░рж┐ DOM
  access ржжрзЗржпрж╝, ржХрж┐ржирзНрждрзБ ржПржЧрзБрж▓рзЛ ржХржо ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи ржПржмржВ рж╢рзБржзрзБржорж╛рждрзНрж░ ржпржЦржи React ржПрж░
  declarative approach ржпржерзЗрж╖рзНржЯ ржиржпрж╝ рждржЦржиржЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржиред
</Callout>
